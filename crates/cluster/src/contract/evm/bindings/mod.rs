#![allow(unused_imports, clippy::all, rustdoc::all)]
//! This module contains the sol! generated bindings for solidity contracts.
//! This is autogenerated code.
//! Do not manually edit these files.
//! These files may be overwritten by the codegen system at any time.
/**

Generated by the following Solidity interface...
```solidity
interface Cluster {
    struct ClusterView {
        KeyspaceView keyspace;
        Migration migration;
        KeyspaceView migrationKeyspace;
        Maintenance maintenance;
        uint64 keyspaceVersion;
        uint128 version;
    }
    struct KeyspaceSlot {
        uint8 idx;
        address operator;
    }
    struct KeyspaceView {
        NodeOperator[] operators;
        uint8 replicationStrategy;
    }
    struct Maintenance {
        address slot;
    }
    struct Migration {
        uint64 id;
        uint256 pullingOperatorsBitmask;
    }
    struct MigrationPlan {
        KeyspaceSlot[] slots;
        uint8 replicationStrategy;
    }
    struct NodeOperator {
        address addr;
        bytes data;
    }
    struct Settings {
        uint16 maxOperatorDataBytes;
    }

    event MaintenanceAborted(uint128 clusterVersion);
    event MaintenanceCompleted(address operatorAddress, uint128 clusterVersion);
    event MaintenanceStarted(address operatorAddress, uint128 clusterVersion);
    event MigrationAborted(uint64 id, uint128 clusterVersion);
    event MigrationCompleted(uint64 id, address operatorAddress, uint128 clusterVersion);
    event MigrationDataPullCompleted(uint64 id, address operatorAddress, uint128 clusterVersion);
    event MigrationStarted(uint64 id, MigrationPlan plan, uint128 clusterVersion);
    event NodeOperatorDataUpdated(address operatorAddress, bytes data, uint128 clusterVersion);

    constructor(Settings initialSettings, address[] initialOperators);

    function abortMaintenance() external;
    function abortMigration() external;
    function completeMaintenance() external;
    function completeMigration(uint64 id, uint8 operatorIdx) external;
    function getView() external view returns (ClusterView memory);
    function registerNodeOperator(bytes memory data) external;
    function startMaintenance(uint8 operatorIdx) external;
    function startMigration(MigrationPlan memory plan) external;
    function transferOwnership(address newOwner) external;
    function updateNodeOperatorData(uint8 operatorIdx, bytes memory data) external;
    function updateSettings(Settings memory newSettings) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "initialSettings",
        "type": "tuple",
        "internalType": "struct Settings",
        "components": [
          {
            "name": "maxOperatorDataBytes",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      },
      {
        "name": "initialOperators",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "abortMaintenance",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "abortMigration",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "completeMaintenance",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "completeMigration",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operatorIdx",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getView",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ClusterView",
        "components": [
          {
            "name": "keyspace",
            "type": "tuple",
            "internalType": "struct KeyspaceView",
            "components": [
              {
                "name": "operators",
                "type": "tuple[]",
                "internalType": "struct NodeOperator[]",
                "components": [
                  {
                    "name": "addr",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "data",
                    "type": "bytes",
                    "internalType": "bytes"
                  }
                ]
              },
              {
                "name": "replicationStrategy",
                "type": "uint8",
                "internalType": "uint8"
              }
            ]
          },
          {
            "name": "migration",
            "type": "tuple",
            "internalType": "struct Migration",
            "components": [
              {
                "name": "id",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "pullingOperatorsBitmask",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "migrationKeyspace",
            "type": "tuple",
            "internalType": "struct KeyspaceView",
            "components": [
              {
                "name": "operators",
                "type": "tuple[]",
                "internalType": "struct NodeOperator[]",
                "components": [
                  {
                    "name": "addr",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "data",
                    "type": "bytes",
                    "internalType": "bytes"
                  }
                ]
              },
              {
                "name": "replicationStrategy",
                "type": "uint8",
                "internalType": "uint8"
              }
            ]
          },
          {
            "name": "maintenance",
            "type": "tuple",
            "internalType": "struct Maintenance",
            "components": [
              {
                "name": "slot",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "keyspaceVersion",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "version",
            "type": "uint128",
            "internalType": "uint128"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerNodeOperator",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startMaintenance",
    "inputs": [
      {
        "name": "operatorIdx",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startMigration",
    "inputs": [
      {
        "name": "plan",
        "type": "tuple",
        "internalType": "struct MigrationPlan",
        "components": [
          {
            "name": "slots",
            "type": "tuple[]",
            "internalType": "struct KeyspaceSlot[]",
            "components": [
              {
                "name": "idx",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "operator",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "replicationStrategy",
            "type": "uint8",
            "internalType": "uint8"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateNodeOperatorData",
    "inputs": [
      {
        "name": "operatorIdx",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateSettings",
    "inputs": [
      {
        "name": "newSettings",
        "type": "tuple",
        "internalType": "struct Settings",
        "components": [
          {
            "name": "maxOperatorDataBytes",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "MaintenanceAborted",
    "inputs": [
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MaintenanceCompleted",
    "inputs": [
      {
        "name": "operatorAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MaintenanceStarted",
    "inputs": [
      {
        "name": "operatorAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MigrationAborted",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MigrationCompleted",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "operatorAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MigrationDataPullCompleted",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "operatorAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "MigrationStarted",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "plan",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct MigrationPlan",
        "components": [
          {
            "name": "slots",
            "type": "tuple[]",
            "internalType": "struct KeyspaceSlot[]",
            "components": [
              {
                "name": "idx",
                "type": "uint8",
                "internalType": "uint8"
              },
              {
                "name": "operator",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "replicationStrategy",
            "type": "uint8",
            "internalType": "uint8"
          }
        ]
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NodeOperatorDataUpdated",
    "inputs": [
      {
        "name": "operatorAddress",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "clusterVersion",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Cluster {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50604051613d0f380380613d0f833981810160405281019061003191906103bd565b335f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550816102075f820151815f015f6101000a81548161ffff021916908361ffff1602179055509050505f5f90505b8151811015610139578181815181106100b8576100b7610417565b5b602002602001015160025f600281106100d4576100d3610417565b5b61010202015f018261010081106100ee576100ed610417565b5b015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808060010191505061009c565b5061014a815161017260201b60201c565b60025f6002811061015e5761015d610417565b5b6101020201610100018190555050506104ad565b5f60018260ff166001901b610187919061047a565b9050919050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6101e9826101a3565b810181811067ffffffffffffffff82111715610208576102076101b3565b5b80604052505050565b5f61021a61018e565b905061022682826101e0565b919050565b5f61ffff82169050919050565b6102418161022b565b811461024b575f5ffd5b50565b5f8151905061025c81610238565b92915050565b5f602082840312156102775761027661019f565b5b6102816020610211565b90505f6102908482850161024e565b5f8301525092915050565b5f5ffd5b5f67ffffffffffffffff8211156102b9576102b86101b3565b5b602082029050602081019050919050565b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6102f7826102ce565b9050919050565b610307816102ed565b8114610311575f5ffd5b50565b5f81519050610322816102fe565b92915050565b5f61033a6103358461029f565b610211565b9050808382526020820190506020840283018581111561035d5761035c6102ca565b5b835b8181101561038657806103728882610314565b84526020840193505060208101905061035f565b5050509392505050565b5f82601f8301126103a4576103a361029b565b5b81516103b4848260208601610328565b91505092915050565b5f5f604083850312156103d3576103d2610197565b5b5f6103e085828601610262565b925050602083015167ffffffffffffffff8111156104015761040061019b565b5b61040d85828601610390565b9150509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f819050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f61048482610444565b915061048f83610444565b92508282039050818111156104a7576104a661044d565b5b92915050565b613855806104ba5f395ff3fe608060405234801561000f575f5ffd5b50600436106100a7575f3560e01c8063ad36e6d01161006f578063ad36e6d014610127578063c130809a14610131578063cdbfc62d1461013b578063dd3fd26914610157578063f019b15414610173578063f2fde38b1461018f576100a7565b80633048bfba146100ab57806355a47d0a146100b557806365706f9c146100d157806375418b9d146100ed5780638b5252d61461010b575b5f5ffd5b6100b36101ab565b005b6100cf60048036038101906100ca919061251f565b61037f565b005b6100eb60048036038101906100e6919061257f565b6106bd565b005b6100f5610761565b60405161010291906128bc565b60405180910390f35b6101256004803603810190610120919061293d565b610f8f565b005b61012f610fec565b005b6101396111c6565b005b610155600480360381019061015091906129a6565b6113c9565b005b610171600480360381019061016c91906129ed565b611a99565b005b61018d60048036038101906101889190612a18565b611d15565b005b6101a960048036038101906101a49190612a9f565b6120ab565b005b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610239576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161023090612b24565b60405180910390fd5b61024161217b565b610280576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161027790612b8c565b60405180910390fd5b5f61020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff16809291906102f190612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f8fb9cd054d0a022110cced239e908b834e4cd219511856d4eaae3051d932d60461020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516103759190612c1d565b60405180910390a1565b6103876121d5565b6103c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103bd90612c80565b60405180910390fd5b6102085f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff168267ffffffffffffffff1614610434576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042b90612ce8565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff1661046f9190612d33565b67ffffffffffffffff166002811061048a57610489612d63565b5b61010202015f018260ff1661010081106104a7576104a6612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461051e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161051590612dda565b60405180910390fd5b61053781610208600101546121e590919063ffffffff16565b6106b95761055481610208600101546121fa90919063ffffffff16565b6102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061058c90612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550505f6102086001015403610646577f01269879535f40ee8957e15e160bf1866c5e2728ff0cbc583d848821e2639b4e6102085f015f9054906101000a900467ffffffffffffffff163361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff1660405161063993929190612e16565b60405180910390a16106b8565b7faf5e90e72015f43138f66b4cd08bd1dfa2839030104f22a00af843fe847c6d196102085f015f9054906101000a900467ffffffffffffffff163361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516106af93929190612e16565b60405180910390a15b5b5050565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161074290612b24565b60405180910390fd5b80610207818161075b9190612f2a565b90505050565b6107696123a7565b6107716123a7565b5f5f5f61077c6121d5565b15610bb9576102085f015f9054906101000a900467ffffffffffffffff1684602001515f019067ffffffffffffffff16908167ffffffffffffffff16815250506102086001015484602001516020018181525050600260016102065f9054906101000a900467ffffffffffffffff166107f59190612f38565b6107ff9190612d33565b67ffffffffffffffff1692505f60026102065f9054906101000a900467ffffffffffffffff1661082f9190612d33565b67ffffffffffffffff1690506108616002826002811061085257610851612d63565b5b6101020201610100015461220e565b91506001826108709190612f73565b67ffffffffffffffff81111561088957610888612fa6565b5b6040519080825280602002602001820160405280156108c257816020015b6108af61240f565b8152602001906001900390816108a75790505b5085604001515f0181905250600281600281106108e2576108e1612d63565b5b6101020201610101015f9054906101000a900460ff1685604001516020019060ff16908160ff16815250505f5f90505b828111610bb257610949816002846002811061093157610930612d63565b5b610102020161010001546121e590919063ffffffff16565b610b9f576002826002811061096157610960612d63565b5b61010202015f0181610100811061097b5761097a612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1693508386604001515f015182815181106109b9576109b8612d63565b5b60200260200101515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050610a268160028760028110610a0e57610a0d612d63565b5b610102020161010001546121e590919063ffffffff16565b80610aab57508373ffffffffffffffffffffffffffffffffffffffff1660028660028110610a5757610a56612d63565b5b61010202015f01826101008110610a7157610a70612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b15610b9e5760015f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208054610af890613000565b80601f0160208091040260200160405190810160405280929190818152602001828054610b2490613000565b8015610b6f5780601f10610b4657610100808354040283529160200191610b6f565b820191905f5260205f20905b815481529060010190602001808311610b5257829003601f168201915b505050505086604001515f01518281518110610b8e57610b8d612d63565b5b6020026020010151602001819052505b5b8080610baa90613030565b915050610912565b5050610be9565b60026102065f9054906101000a900467ffffffffffffffff16610bdc9190612d33565b67ffffffffffffffff1692505b610c0f60028460028110610c0057610bff612d63565b5b6101020201610100015461220e565b9050600181610c1e9190612f73565b67ffffffffffffffff811115610c3757610c36612fa6565b5b604051908082528060200260200182016040528015610c7057816020015b610c5d61240f565b815260200190600190039081610c555790505b50845f01515f018190525060028360028110610c8f57610c8e612d63565b5b6101020201610101015f9054906101000a900460ff16845f01516020019060ff16908160ff16815250505f5f90505b818111610ea157610cf58160028660028110610cdd57610cdc612d63565b5b610102020161010001546121e590919063ffffffff16565b610e8e5760028460028110610d0d57610d0c612d63565b5b61010202015f01816101008110610d2757610d26612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16925082855f01515f01518281518110610d6457610d63612d63565b5b60200260200101515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208054610de990613000565b80601f0160208091040260200160405190810160405280929190818152602001828054610e1590613000565b8015610e605780601f10610e3757610100808354040283529160200191610e60565b820191905f5260205f20905b815481529060010190602001808311610e4357829003601f168201915b5050505050855f01515f01518281518110610e7e57610e7d612d63565b5b6020026020010151602001819052505b8080610e9990613030565b915050610cbe565b506102065f9054906101000a900467ffffffffffffffff16846080019067ffffffffffffffff16908167ffffffffffffffff168152505061020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684606001515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061020b5f9054906101000a90046fffffffffffffffffffffffffffffffff168460a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508394505050505090565b610f9b8282905061221f565b818160015f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209182610fe7929190613218565b505050565b610ff461217b565b611033576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161102a90612b8c565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff1661020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146110c5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110bc90612dda565b60405180910390fd5b5f61020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061113690612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507ff91067eb420c28d3124865fc996e6aa9d541b9b4fef9188cb965a6cc6491638e3361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516111bc9291906132e5565b60405180910390a1565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611254576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161124b90612b24565b60405180910390fd5b61125c6121d5565b61129b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161129290612c80565b60405180910390fd5b6102065f81819054906101000a900467ffffffffffffffff16809291906112c19061330c565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f6102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061132190612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507ff73240422246f63ed633ef3ce0726b8ab8fb69d46c8a4e5ecb0b2922668674a16102085f015f9054906101000a900467ffffffffffffffff1661020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516113bf929190613333565b60405180910390a1565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611457576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161144e90612b24565b60405180910390fd5b61145f6121d5565b1561149f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611496906133a4565b60405180910390fd5b6114a761217b565b156114e7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114de9061340c565b60405180910390fd5b6102085f015f81819054906101000a900467ffffffffffffffff168092919061150f9061342a565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f60026102065f9054906101000a900467ffffffffffffffff1661155a9190612d33565b67ffffffffffffffff1690506102065f81819054906101000a900467ffffffffffffffff168092919061158c9061342a565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f60026102065f9054906101000a900467ffffffffffffffff166115d79190612d33565b67ffffffffffffffff1690505f5f90505b61160e600284600281106115ff576115fe612d63565b5b6101020201610100015461220e565b81116117b2576002836002811061162857611627612d63565b5b61010202015f0181610100811061164257611641612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166002836002811061168d5761168c612d63565b5b61010202015f018261010081106116a7576116a6612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461179f57600283600281106116f7576116f6612d63565b5b61010202015f0181610100811061171157611710612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166002836002811061174657611745612d63565b5b61010202015f018261010081106117605761175f612d63565b5b015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b80806117aa90613030565b9150506115e8565b505f600283600281106117c8576117c7612d63565b5b6101020201610100015490505f5f5f5f90505b86805f01906117ea9190613465565b90508110156119465786805f01906118029190613465565b8281811061181357611812612d63565b5b9050604002015f01602081019061182a91906129ed565b925086805f019061183b9190613465565b8281811061184c5761184b612d63565b5b90506040020160200160208101906118649190612a9f565b91505f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036118b3576118ac83856121fa90919063ffffffff16565b93506118c9565b6118c683856122bd90919063ffffffff16565b93505b81600286600281106118de576118dd612d63565b5b61010202015f018460ff1661010081106118fb576118fa612d63565b5b015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506117db565b50826002856002811061195c5761195b612d63565b5b6101020201610100018190555085602001602081019061197c91906129ed565b600285600281106119905761198f612d63565b5b6101020201610101015f6101000a81548160ff021916908360ff160217905550826102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff16809291906119e990612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f78dad2bc0b47c688ed84f3fee79abc18e6c9822db05a79ca19dff54533c7470d6102085f015f9054906101000a900467ffffffffffffffff168761020b5f9054906101000a90046fffffffffffffffffffffffffffffffff16604051611a899392919061368b565b60405180910390a1505050505050565b611aa16121d5565b15611ae1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ad8906133a4565b60405180910390fd5b611ae961217b565b15611b29576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b209061340c565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611b649190612d33565b67ffffffffffffffff1660028110611b7f57611b7e612d63565b5b61010202015f018260ff166101008110611b9c57611b9b612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611c13576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c0a90612dda565b60405180910390fd5b3361020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff1680929190611c8490612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507fbc2748cf02f7a1291525e866efc76ab3b96d32d7afcbb26c53daec617b38b4793361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff16604051611d0a9291906132e5565b60405180910390a150565b611d218282905061221f565b5f5f611d2b6121d5565b15611ea1573373ffffffffffffffffffffffffffffffffffffffff1660028060016102065f9054906101000a900467ffffffffffffffff16611d6d9190612f38565b611d779190612d33565b67ffffffffffffffff1660028110611d9257611d91612d63565b5b61010202015f018660ff166101008110611daf57611dae612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614915081611e9c573373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611e299190612d33565b67ffffffffffffffff1660028110611e4457611e43612d63565b5b61010202015f018660ff166101008110611e6157611e60612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161490505b611f4f565b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611edc9190612d33565b67ffffffffffffffff1660028110611ef757611ef6612d63565b5b61010202015f018660ff166101008110611f1457611f13612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161491505b8180611f585750805b611f97576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f8e90612dda565b60405180910390fd5b838360015f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209182611fe3929190613218565b5061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061201290612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f125181ec21882dec51a2392905dff3a82cbd0262f18b5c0c035488671b40afb233858561020b5f9054906101000a90046fffffffffffffffffffffffffffffffff1660405161209c9493929190613711565b60405180910390a15050505050565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612139576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161213090612b24565b60405180910390fd5b805f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b5f5f73ffffffffffffffffffffffffffffffffffffffff1661020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905090565b5f5f610208600101541415905090565b5f5f8260ff166001901b841614905092915050565b5f8160ff166001901b198316905092915050565b5f612218826122d0565b9050919050565b5f8111612261576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161225890613799565b60405180910390fd5b6102075f015f9054906101000a900461ffff1661ffff168111156122ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016122b190613801565b60405180910390fd5b50565b5f8160ff166001901b8317905092915050565b5f60076122ee6fffffffffffffffffffffffffffffffff841161239c565b901b9050600661230a67ffffffffffffffff8385901c1161239c565b901b81179050600561232463ffffffff8385901c1161239c565b901b81179050600461233c61ffff8385901c1161239c565b901b81179050600361235360ff8385901c1161239c565b901b81179050600261236a600f8385901c1161239c565b901b811790507d01010202020203030303030303030000000000000000000000000000000082821c1a81179050919050565b5f8115159050919050565b6040518060c001604052806123ba61243e565b81526020016123c761245a565b81526020016123d461243e565b81526020016123e161247c565b81526020015f67ffffffffffffffff1681526020015f6fffffffffffffffffffffffffffffffff1681525090565b60405180604001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060400160405280606081526020015f60ff1681525090565b60405180604001604052805f67ffffffffffffffff1681526020015f81525090565b60405180602001604052805f73ffffffffffffffffffffffffffffffffffffffff1681525090565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82169050919050565b6124c8816124ac565b81146124d2575f5ffd5b50565b5f813590506124e3816124bf565b92915050565b5f60ff82169050919050565b6124fe816124e9565b8114612508575f5ffd5b50565b5f81359050612519816124f5565b92915050565b5f5f60408385031215612535576125346124a4565b5b5f612542858286016124d5565b92505060206125538582860161250b565b9150509250929050565b5f5ffd5b5f602082840312156125765761257561255d565b5b81905092915050565b5f60208284031215612594576125936124a4565b5b5f6125a184828501612561565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6125fc826125d3565b9050919050565b61260c816125f2565b82525050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f61265482612612565b61265e818561261c565b935061266e81856020860161262c565b6126778161263a565b840191505092915050565b5f604083015f8301516126975f860182612603565b50602083015184820360208601526126af828261264a565b9150508091505092915050565b5f6126c78383612682565b905092915050565b5f602082019050919050565b5f6126e5826125aa565b6126ef81856125b4565b935083602082028501612701856125c4565b805f5b8581101561273c578484038952815161271d85826126bc565b9450612728836126cf565b925060208a01995050600181019050612704565b50829750879550505050505092915050565b612757816124e9565b82525050565b5f604083015f8301518482035f86015261277782826126db565b915050602083015161278c602086018261274e565b508091505092915050565b6127a0816124ac565b82525050565b5f819050919050565b6127b8816127a6565b82525050565b604082015f8201516127d25f850182612797565b5060208201516127e560208501826127af565b50505050565b602082015f8201516127ff5f850182612603565b50505050565b5f6fffffffffffffffffffffffffffffffff82169050919050565b61282981612805565b82525050565b5f60e083015f8301518482035f860152612849828261275d565b915050602083015161285e60208601826127be565b5060408301518482036060860152612876828261275d565b915050606083015161288b60808601826127eb565b50608083015161289e60a0860182612797565b5060a08301516128b160c0860182612820565b508091505092915050565b5f6020820190508181035f8301526128d4818461282f565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126128fd576128fc6128dc565b5b8235905067ffffffffffffffff81111561291a576129196128e0565b5b602083019150836001820283011115612936576129356128e4565b5b9250929050565b5f5f60208385031215612953576129526124a4565b5b5f83013567ffffffffffffffff8111156129705761296f6124a8565b5b61297c858286016128e8565b92509250509250929050565b5f6040828403121561299d5761299c61255d565b5b81905092915050565b5f602082840312156129bb576129ba6124a4565b5b5f82013567ffffffffffffffff8111156129d8576129d76124a8565b5b6129e484828501612988565b91505092915050565b5f60208284031215612a0257612a016124a4565b5b5f612a0f8482850161250b565b91505092915050565b5f5f5f60408486031215612a2f57612a2e6124a4565b5b5f612a3c8682870161250b565b935050602084013567ffffffffffffffff811115612a5d57612a5c6124a8565b5b612a69868287016128e8565b92509250509250925092565b612a7e816125f2565b8114612a88575f5ffd5b50565b5f81359050612a9981612a75565b92915050565b5f60208284031215612ab457612ab36124a4565b5b5f612ac184828501612a8b565b91505092915050565b5f82825260208201905092915050565b7f6e6f7420746865206f776e6572000000000000000000000000000000000000005f82015250565b5f612b0e600d83612aca565b9150612b1982612ada565b602082019050919050565b5f6020820190508181035f830152612b3b81612b02565b9050919050565b7f6e6f206d61696e74656e616e63650000000000000000000000000000000000005f82015250565b5f612b76600e83612aca565b9150612b8182612b42565b602082019050919050565b5f6020820190508181035f830152612ba381612b6a565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612be182612805565b91506fffffffffffffffffffffffffffffffff8203612c0357612c02612baa565b5b600182019050919050565b612c1781612805565b82525050565b5f602082019050612c305f830184612c0e565b92915050565b7f6e6f206d6967726174696f6e00000000000000000000000000000000000000005f82015250565b5f612c6a600c83612aca565b9150612c7582612c36565b602082019050919050565b5f6020820190508181035f830152612c9781612c5e565b9050919050565b7f77726f6e67206d6967726174696f6e20696400000000000000000000000000005f82015250565b5f612cd2601283612aca565b9150612cdd82612c9e565b602082019050919050565b5f6020820190508181035f830152612cff81612cc6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f612d3d826124ac565b9150612d48836124ac565b925082612d5857612d57612d06565b5b828206905092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f77726f6e67206f70657261746f720000000000000000000000000000000000005f82015250565b5f612dc4600e83612aca565b9150612dcf82612d90565b602082019050919050565b5f6020820190508181035f830152612df181612db8565b9050919050565b612e01816124ac565b82525050565b612e10816125f2565b82525050565b5f606082019050612e295f830186612df8565b612e366020830185612e07565b612e436040830184612c0e565b949350505050565b5f61ffff82169050919050565b612e6181612e4b565b8114612e6b575f5ffd5b50565b5f8135612e7a81612e58565b80915050919050565b5f815f1b9050919050565b5f61ffff612e9b84612e83565b9350801983169250808416831791505092915050565b5f819050919050565b5f612ed4612ecf612eca84612e4b565b612eb1565b612e4b565b9050919050565b5f819050919050565b612eed82612eba565b612f00612ef982612edb565b8354612e8e565b8255505050565b5f81015f830180612f1781612e6e565b9050612f238184612ee4565b5050505050565b612f348282612f07565b5050565b5f612f42826124ac565b9150612f4d836124ac565b9250828203905067ffffffffffffffff811115612f6d57612f6c612baa565b5b92915050565b5f612f7d826127a6565b9150612f88836127a6565b9250828201905080821115612fa057612f9f612baa565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061301757607f821691505b60208210810361302a57613029612fd3565b5b50919050565b5f61303a826127a6565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361306c5761306b612baa565b5b600182019050919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026130dd7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826130a2565b6130e786836130a2565b95508019841693508086168417925050509392505050565b5f61311961311461310f846127a6565b612eb1565b6127a6565b9050919050565b5f819050919050565b613132836130ff565b61314661313e82613120565b8484546130ae565b825550505050565b5f5f905090565b61315d61314e565b613168818484613129565b505050565b5b8181101561318b576131805f82613155565b60018101905061316e565b5050565b601f8211156131d0576131a181613081565b6131aa84613093565b810160208510156131b9578190505b6131cd6131c585613093565b83018261316d565b50505b505050565b5f82821c905092915050565b5f6131f05f19846008026131d5565b1980831691505092915050565b5f61320883836131e1565b9150826002028217905092915050565b6132228383613077565b67ffffffffffffffff81111561323b5761323a612fa6565b5b6132458254613000565b61325082828561318f565b5f601f83116001811461327d575f841561326b578287013590505b61327585826131fd565b8655506132dc565b601f19841661328b86613081565b5f5b828110156132b25784890135825560018201915060208501945060208101905061328d565b868310156132cf57848901356132cb601f8916826131e1565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506132f85f830185612e07565b6133056020830184612c0e565b9392505050565b5f613316826124ac565b91505f820361332857613327612baa565b5b600182039050919050565b5f6040820190506133465f830185612df8565b6133536020830184612c0e565b9392505050565b7f6d6967726174696f6e20696e2070726f677265737300000000000000000000005f82015250565b5f61338e601583612aca565b91506133998261335a565b602082019050919050565b5f6020820190508181035f8301526133bb81613382565b9050919050565b7f6d61696e74656e616e636520696e2070726f67726573730000000000000000005f82015250565b5f6133f6601783612aca565b9150613401826133c2565b602082019050919050565b5f6020820190508181035f830152613423816133ea565b9050919050565b5f613434826124ac565b915067ffffffffffffffff820361344e5761344d612baa565b5b600182019050919050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f8335600160200384360303811261348157613480613459565b5b80840192508235915067ffffffffffffffff8211156134a3576134a261345d565b5b6020830192506040820236038313156134bf576134be613461565b5b509250929050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f833560016020038436030381126134ef576134ee6134cf565b5b83810192508235915060208301925067ffffffffffffffff821115613517576135166134c7565b5b60408202360383131561352d5761352c6134cb565b5b509250929050565b5f82825260208201905092915050565b5f819050919050565b5f61355c602084018461250b565b905092915050565b5f6135726020840184612a8b565b905092915050565b6040820161358a5f83018361354e565b6135965f85018261274e565b506135a46020830183613564565b6135b16020850182612603565b50505050565b5f6135c2838361357a565b60408301905092915050565b5f82905092915050565b5f604082019050919050565b5f6135ef8385613535565b93506135fa82613545565b805f5b858110156136325761360f82846135ce565b61361988826135b7565b9750613624836135d8565b9250506001810190506135fd565b5085925050509392505050565b5f604083016136505f8401846134d3565b8583035f8701526136628382846135e4565b92505050613673602084018461354e565b613680602086018261274e565b508091505092915050565b5f60608201905061369e5f830186612df8565b81810360208301526136b0818561363f565b90506136bf6040830184612c0e565b949350505050565b5f82825260208201905092915050565b828183375f83830152505050565b5f6136f083856136c7565b93506136fd8385846136d7565b6137068361263a565b840190509392505050565b5f6060820190506137245f830187612e07565b81810360208301526137378185876136e5565b90506137466040830184612c0e565b95945050505050565b7f656d707479206f70657261746f722064617461000000000000000000000000005f82015250565b5f613783601383612aca565b915061378e8261374f565b602082019050919050565b5f6020820190508181035f8301526137b081613777565b9050919050565b7f6f70657261746f72206461746120746f6f206c617267650000000000000000005f82015250565b5f6137eb601783612aca565b91506137f6826137b7565b602082019050919050565b5f6020820190508181035f830152613818816137df565b905091905056fea2646970667358221220fa04dead425e6aa2ee51652b77cd8bec344f89d5a5d18b42f4889b7abad1732264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa=\x0F8\x03\x80a=\x0F\x839\x81\x81\x01`@R\x81\x01\x90a\x001\x91\x90a\x03\xBDV[3__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x81a\x02\x07_\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81a\xFF\xFF\x02\x19\x16\x90\x83a\xFF\xFF\x16\x02\x17\x90UP\x90PP__\x90P[\x81Q\x81\x10\x15a\x019W\x81\x81\x81Q\x81\x10a\0\xB8Wa\0\xB7a\x04\x17V[[` \x02` \x01\x01Q`\x02_`\x02\x81\x10a\0\xD4Wa\0\xD3a\x04\x17V[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\0\xEEWa\0\xEDa\x04\x17V[[\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\0\x9CV[Pa\x01J\x81Qa\x01r` \x1B` \x1CV[`\x02_`\x02\x81\x10a\x01^Wa\x01]a\x04\x17V[[a\x01\x02\x02\x01a\x01\0\x01\x81\x90UPPPa\x04\xADV[_`\x01\x82`\xFF\x16`\x01\x90\x1Ba\x01\x87\x91\x90a\x04zV[\x90P\x91\x90PV[_`@Q\x90P\x90V[__\xFD[__\xFD[__\xFD[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[a\x01\xE9\x82a\x01\xA3V[\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x02\x08Wa\x02\x07a\x01\xB3V[[\x80`@RPPPV[_a\x02\x1Aa\x01\x8EV[\x90Pa\x02&\x82\x82a\x01\xE0V[\x91\x90PV[_a\xFF\xFF\x82\x16\x90P\x91\x90PV[a\x02A\x81a\x02+V[\x81\x14a\x02KW__\xFD[PV[_\x81Q\x90Pa\x02\\\x81a\x028V[\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x02wWa\x02va\x01\x9FV[[a\x02\x81` a\x02\x11V[\x90P_a\x02\x90\x84\x82\x85\x01a\x02NV[_\x83\x01RP\x92\x91PPV[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x02\xB9Wa\x02\xB8a\x01\xB3V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[__\xFD[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a\x02\xF7\x82a\x02\xCEV[\x90P\x91\x90PV[a\x03\x07\x81a\x02\xEDV[\x81\x14a\x03\x11W__\xFD[PV[_\x81Q\x90Pa\x03\"\x81a\x02\xFEV[\x92\x91PPV[_a\x03:a\x035\x84a\x02\x9FV[a\x02\x11V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x03]Wa\x03\\a\x02\xCAV[[\x83[\x81\x81\x10\x15a\x03\x86W\x80a\x03r\x88\x82a\x03\x14V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x03_V[PPP\x93\x92PPPV[_\x82`\x1F\x83\x01\x12a\x03\xA4Wa\x03\xA3a\x02\x9BV[[\x81Qa\x03\xB4\x84\x82` \x86\x01a\x03(V[\x91PP\x92\x91PPV[__`@\x83\x85\x03\x12\x15a\x03\xD3Wa\x03\xD2a\x01\x97V[[_a\x03\xE0\x85\x82\x86\x01a\x02bV[\x92PP` \x83\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\x01Wa\x04\0a\x01\x9BV[[a\x04\r\x85\x82\x86\x01a\x03\x90V[\x91PP\x92P\x92\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[_\x81\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a\x04\x84\x82a\x04DV[\x91Pa\x04\x8F\x83a\x04DV[\x92P\x82\x82\x03\x90P\x81\x81\x11\x15a\x04\xA7Wa\x04\xA6a\x04MV[[\x92\x91PPV[a8U\x80a\x04\xBA_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\xA7W_5`\xE0\x1C\x80c\xAD6\xE6\xD0\x11a\0oW\x80c\xAD6\xE6\xD0\x14a\x01'W\x80c\xC10\x80\x9A\x14a\x011W\x80c\xCD\xBF\xC6-\x14a\x01;W\x80c\xDD?\xD2i\x14a\x01WW\x80c\xF0\x19\xB1T\x14a\x01sW\x80c\xF2\xFD\xE3\x8B\x14a\x01\x8FWa\0\xA7V[\x80c0H\xBF\xBA\x14a\0\xABW\x80cU\xA4}\n\x14a\0\xB5W\x80cepo\x9C\x14a\0\xD1W\x80cuA\x8B\x9D\x14a\0\xEDW\x80c\x8BRR\xD6\x14a\x01\x0BW[__\xFD[a\0\xB3a\x01\xABV[\0[a\0\xCF`\x04\x806\x03\x81\x01\x90a\0\xCA\x91\x90a%\x1FV[a\x03\x7FV[\0[a\0\xEB`\x04\x806\x03\x81\x01\x90a\0\xE6\x91\x90a%\x7FV[a\x06\xBDV[\0[a\0\xF5a\x07aV[`@Qa\x01\x02\x91\x90a(\xBCV[`@Q\x80\x91\x03\x90\xF3[a\x01%`\x04\x806\x03\x81\x01\x90a\x01 \x91\x90a)=V[a\x0F\x8FV[\0[a\x01/a\x0F\xECV[\0[a\x019a\x11\xC6V[\0[a\x01U`\x04\x806\x03\x81\x01\x90a\x01P\x91\x90a)\xA6V[a\x13\xC9V[\0[a\x01q`\x04\x806\x03\x81\x01\x90a\x01l\x91\x90a)\xEDV[a\x1A\x99V[\0[a\x01\x8D`\x04\x806\x03\x81\x01\x90a\x01\x88\x91\x90a*\x18V[a\x1D\x15V[\0[a\x01\xA9`\x04\x806\x03\x81\x01\x90a\x01\xA4\x91\x90a*\x9FV[a \xABV[\0[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x029W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x020\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x02Aa!{V[a\x02\x80W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02w\x90a+\x8CV[`@Q\x80\x91\x03\x90\xFD[_a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x02\xF1\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\x8F\xB9\xCD\x05M\n\x02!\x10\xCC\xED#\x9E\x90\x8B\x83NL\xD2\x19Q\x18V\xD4\xEA\xAE0Q\xD92\xD6\x04a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x03u\x91\x90a,\x1DV[`@Q\x80\x91\x03\x90\xA1V[a\x03\x87a!\xD5V[a\x03\xC6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\xBD\x90a,\x80V[`@Q\x80\x91\x03\x90\xFD[a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x044W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04+\x90a,\xE8V[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04o\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x04\x8AWa\x04\x89a-cV[[a\x01\x02\x02\x01_\x01\x82`\xFF\x16a\x01\0\x81\x10a\x04\xA7Wa\x04\xA6a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\x1EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x15\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[a\x057\x81a\x02\x08`\x01\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x06\xB9Wa\x05T\x81a\x02\x08`\x01\x01Ta!\xFA\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x05\x8C\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_a\x02\x08`\x01\x01T\x03a\x06FW\x7F\x01&\x98yS_@\xEE\x89W\xE1^\x16\x0B\xF1\x86l^'(\xFF\x0C\xBCX=\x84\x88!\xE2c\x9BNa\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x069\x93\x92\x91\x90a.\x16V[`@Q\x80\x91\x03\x90\xA1a\x06\xB8V[\x7F\xAF^\x90\xE7 \x15\xF418\xF6kL\xD0\x8B\xD1\xDF\xA2\x83\x900\x10O\"\xA0\n\xF8C\xFE\x84|m\x19a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x06\xAF\x93\x92\x91\x90a.\x16V[`@Q\x80\x91\x03\x90\xA1[[PPV[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07KW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07B\x90a+$V[`@Q\x80\x91\x03\x90\xFD[\x80a\x02\x07\x81\x81a\x07[\x91\x90a/*V[\x90PPPV[a\x07ia#\xA7V[a\x07qa#\xA7V[___a\x07|a!\xD5V[\x15a\x0B\xB9Wa\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84` \x01Q_\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\x08`\x01\x01T\x84` \x01Q` \x01\x81\x81RPP`\x02`\x01a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xF5\x91\x90a/8V[a\x07\xFF\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08/\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90Pa\x08a`\x02\x82`\x02\x81\x10a\x08RWa\x08Qa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x91P`\x01\x82a\x08p\x91\x90a/sV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08\x89Wa\x08\x88a/\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\xC2W\x81` \x01[a\x08\xAFa$\x0FV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x08\xA7W\x90P[P\x85`@\x01Q_\x01\x81\x90RP`\x02\x81`\x02\x81\x10a\x08\xE2Wa\x08\xE1a-cV[[a\x01\x02\x02\x01a\x01\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x85`@\x01Q` \x01\x90`\xFF\x16\x90\x81`\xFF\x16\x81RPP__\x90P[\x82\x81\x11a\x0B\xB2Wa\tI\x81`\x02\x84`\x02\x81\x10a\t1Wa\t0a-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x0B\x9FW`\x02\x82`\x02\x81\x10a\taWa\t`a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\t{Wa\tza-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93P\x83\x86`@\x01Q_\x01Q\x82\x81Q\x81\x10a\t\xB9Wa\t\xB8a-cV[[` \x02` \x01\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\n&\x81`\x02\x87`\x02\x81\x10a\n\x0EWa\n\ra-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80a\n\xABWP\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x86`\x02\x81\x10a\nWWa\nVa-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\nqWa\npa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x0B\x9EW`\x01_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x80Ta\n\xF8\x90a0\0V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B$\x90a0\0V[\x80\x15a\x0BoW\x80`\x1F\x10a\x0BFWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BoV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0BRW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x86`@\x01Q_\x01Q\x82\x81Q\x81\x10a\x0B\x8EWa\x0B\x8Da-cV[[` \x02` \x01\x01Q` \x01\x81\x90RP[[\x80\x80a\x0B\xAA\x90a00V[\x91PPa\t\x12V[PPa\x0B\xE9V[`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0B\xDC\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P[a\x0C\x0F`\x02\x84`\x02\x81\x10a\x0C\0Wa\x0B\xFFa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x90P`\x01\x81a\x0C\x1E\x91\x90a/sV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C7Wa\x0C6a/\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0CpW\x81` \x01[a\x0C]a$\x0FV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x0CUW\x90P[P\x84_\x01Q_\x01\x81\x90RP`\x02\x83`\x02\x81\x10a\x0C\x8FWa\x0C\x8Ea-cV[[a\x01\x02\x02\x01a\x01\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x84_\x01Q` \x01\x90`\xFF\x16\x90\x81`\xFF\x16\x81RPP__\x90P[\x81\x81\x11a\x0E\xA1Wa\x0C\xF5\x81`\x02\x86`\x02\x81\x10a\x0C\xDDWa\x0C\xDCa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x0E\x8EW`\x02\x84`\x02\x81\x10a\r\rWa\r\x0Ca-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\r'Wa\r&a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P\x82\x85_\x01Q_\x01Q\x82\x81Q\x81\x10a\rdWa\rca-cV[[` \x02` \x01\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP`\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x80Ta\r\xE9\x90a0\0V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0E\x15\x90a0\0V[\x80\x15a\x0E`W\x80`\x1F\x10a\x0E7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0E`V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0ECW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x85_\x01Q_\x01Q\x82\x81Q\x81\x10a\x0E~Wa\x0E}a-cV[[` \x02` \x01\x01Q` \x01\x81\x90RP[\x80\x80a\x0E\x99\x90a00V[\x91PPa\x0C\xBEV[Pa\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`\x80\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84``\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`\xA0\x01\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x94PPPPP\x90V[a\x0F\x9B\x82\x82\x90Pa\"\x1FV[\x81\x81`\x01_3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x91\x82a\x0F\xE7\x92\x91\x90a2\x18V[PPPV[a\x0F\xF4a!{V[a\x103W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10*\x90a+\x8CV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10\xC5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\xBC\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[_a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x116\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xF9\x10g\xEBB\x0C(\xD3\x12He\xFC\x99nj\xA9\xD5A\xB9\xB4\xFE\xF9\x18\x8C\xB9e\xA6\xCCd\x91c\x8E3a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x11\xBC\x92\x91\x90a2\xE5V[`@Q\x80\x91\x03\x90\xA1V[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12TW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12K\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x12\\a!\xD5V[a\x12\x9BW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\x92\x90a,\x80V[`@Q\x80\x91\x03\x90\xFD[a\x02\x06_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x12\xC1\x90a3\x0CV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x13!\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xF72@B\"F\xF6>\xD63\xEF<\xE0rk\x8A\xB8\xFBi\xD4l\x8AN^\xCB\x0B)\"f\x86t\xA1a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x13\xBF\x92\x91\x90a33V[`@Q\x80\x91\x03\x90\xA1V[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x14WW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14N\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x14_a!\xD5V[\x15a\x14\x9FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x96\x90a3\xA4V[`@Q\x80\x91\x03\x90\xFD[a\x14\xA7a!{V[\x15a\x14\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xDE\x90a4\x0CV[`@Q\x80\x91\x03\x90\xFD[a\x02\x08_\x01_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x15\x0F\x90a4*V[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15Z\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90Pa\x02\x06_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x15\x8C\x90a4*V[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\xD7\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P__\x90P[a\x16\x0E`\x02\x84`\x02\x81\x10a\x15\xFFWa\x15\xFEa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x81\x11a\x17\xB2W`\x02\x83`\x02\x81\x10a\x16(Wa\x16'a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\x16BWa\x16Aa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x83`\x02\x81\x10a\x16\x8DWa\x16\x8Ca-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\x16\xA7Wa\x16\xA6a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\x9FW`\x02\x83`\x02\x81\x10a\x16\xF7Wa\x16\xF6a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\x17\x11Wa\x17\x10a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x83`\x02\x81\x10a\x17FWa\x17Ea-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\x17`Wa\x17_a-cV[[\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[\x80\x80a\x17\xAA\x90a00V[\x91PPa\x15\xE8V[P_`\x02\x83`\x02\x81\x10a\x17\xC8Wa\x17\xC7a-cV[[a\x01\x02\x02\x01a\x01\0\x01T\x90P____\x90P[\x86\x80_\x01\x90a\x17\xEA\x91\x90a4eV[\x90P\x81\x10\x15a\x19FW\x86\x80_\x01\x90a\x18\x02\x91\x90a4eV[\x82\x81\x81\x10a\x18\x13Wa\x18\x12a-cV[[\x90P`@\x02\x01_\x01` \x81\x01\x90a\x18*\x91\x90a)\xEDV[\x92P\x86\x80_\x01\x90a\x18;\x91\x90a4eV[\x82\x81\x81\x10a\x18LWa\x18Ka-cV[[\x90P`@\x02\x01` \x01` \x81\x01\x90a\x18d\x91\x90a*\x9FV[\x91P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x18\xB3Wa\x18\xAC\x83\x85a!\xFA\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x93Pa\x18\xC9V[a\x18\xC6\x83\x85a\"\xBD\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x93P[\x81`\x02\x86`\x02\x81\x10a\x18\xDEWa\x18\xDDa-cV[[a\x01\x02\x02\x01_\x01\x84`\xFF\x16a\x01\0\x81\x10a\x18\xFBWa\x18\xFAa-cV[[\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x17\xDBV[P\x82`\x02\x85`\x02\x81\x10a\x19\\Wa\x19[a-cV[[a\x01\x02\x02\x01a\x01\0\x01\x81\x90UP\x85` \x01` \x81\x01\x90a\x19|\x91\x90a)\xEDV[`\x02\x85`\x02\x81\x10a\x19\x90Wa\x19\x8Fa-cV[[a\x01\x02\x02\x01a\x01\x01\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\xFF\x16\x02\x17\x90UP\x82a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x19\xE9\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7Fx\xDA\xD2\xBC\x0BG\xC6\x88\xED\x84\xF3\xFE\xE7\x9A\xBC\x18\xE6\xC9\x82-\xB0Zy\xCA\x19\xDF\xF5E3\xC7G\ra\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x1A\x89\x93\x92\x91\x90a6\x8BV[`@Q\x80\x91\x03\x90\xA1PPPPPPV[a\x1A\xA1a!\xD5V[\x15a\x1A\xE1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xD8\x90a3\xA4V[`@Q\x80\x91\x03\x90\xFD[a\x1A\xE9a!{V[\x15a\x1B)W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B \x90a4\x0CV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Bd\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1B\x7FWa\x1B~a-cV[[a\x01\x02\x02\x01_\x01\x82`\xFF\x16a\x01\0\x81\x10a\x1B\x9CWa\x1B\x9Ba-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\x13W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\n\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[3a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x1C\x84\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xBC'H\xCF\x02\xF7\xA1)\x15%\xE8f\xEF\xC7j\xB3\xB9m2\xD7\xAF\xCB\xB2lS\xDA\xECa{8\xB4y3a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x1D\n\x92\x91\x90a2\xE5V[`@Q\x80\x91\x03\x90\xA1PV[a\x1D!\x82\x82\x90Pa\"\x1FV[__a\x1D+a!\xD5V[\x15a\x1E\xA1W3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80`\x01a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Dm\x91\x90a/8V[a\x1Dw\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1D\x92Wa\x1D\x91a-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1D\xAFWa\x1D\xAEa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x91P\x81a\x1E\x9CW3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E)\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1EDWa\x1ECa-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1EaWa\x1E`a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x90P[a\x1FOV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E\xDC\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1E\xF7Wa\x1E\xF6a-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1F\x14Wa\x1F\x13a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x91P[\x81\x80a\x1FXWP\x80[a\x1F\x97W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x8E\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[\x83\x83`\x01_3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x91\x82a\x1F\xE3\x92\x91\x90a2\x18V[Pa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a \x12\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\x12Q\x81\xEC!\x88-\xECQ\xA29)\x05\xDF\xF3\xA8,\xBD\x02b\xF1\x8B\\\x0C\x03T\x88g\x1B@\xAF\xB23\x85\x85a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa \x9C\x94\x93\x92\x91\x90a7\x11V[`@Q\x80\x91\x03\x90\xA1PPPPPV[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a!9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!0\x90a+$V[`@Q\x80\x91\x03\x90\xFD[\x80__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[__s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x90P\x90V[__a\x02\x08`\x01\x01T\x14\x15\x90P\x90V[__\x82`\xFF\x16`\x01\x90\x1B\x84\x16\x14\x90P\x92\x91PPV[_\x81`\xFF\x16`\x01\x90\x1B\x19\x83\x16\x90P\x92\x91PPV[_a\"\x18\x82a\"\xD0V[\x90P\x91\x90PV[_\x81\x11a\"aW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"X\x90a7\x99V[`@Q\x80\x91\x03\x90\xFD[a\x02\x07_\x01_\x90T\x90a\x01\0\n\x90\x04a\xFF\xFF\x16a\xFF\xFF\x16\x81\x11\x15a\"\xBAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\xB1\x90a8\x01V[`@Q\x80\x91\x03\x90\xFD[PV[_\x81`\xFF\x16`\x01\x90\x1B\x83\x17\x90P\x92\x91PPV[_`\x07a\"\xEEo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a#\x9CV[\x90\x1B\x90P`\x06a#\ng\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x05a#$c\xFF\xFF\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x04a#<a\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x03a#S`\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x02a#j`\x0F\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P}\x01\x01\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x1C\x1A\x81\x17\x90P\x91\x90PV[_\x81\x15\x15\x90P\x91\x90PV[`@Q\x80`\xC0\x01`@R\x80a#\xBAa$>V[\x81R` \x01a#\xC7a$ZV[\x81R` \x01a#\xD4a$>V[\x81R` \x01a#\xE1a$|V[\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90V[`@Q\x80`@\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`@\x01`@R\x80``\x81R` \x01_`\xFF\x16\x81RP\x90V[`@Q\x80`@\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81RP\x90V[`@Q\x80` \x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90V[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a$\xC8\x81a$\xACV[\x81\x14a$\xD2W__\xFD[PV[_\x815\x90Pa$\xE3\x81a$\xBFV[\x92\x91PPV[_`\xFF\x82\x16\x90P\x91\x90PV[a$\xFE\x81a$\xE9V[\x81\x14a%\x08W__\xFD[PV[_\x815\x90Pa%\x19\x81a$\xF5V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a%5Wa%4a$\xA4V[[_a%B\x85\x82\x86\x01a$\xD5V[\x92PP` a%S\x85\x82\x86\x01a%\x0BV[\x91PP\x92P\x92\x90PV[__\xFD[_` \x82\x84\x03\x12\x15a%vWa%ua%]V[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a%\x94Wa%\x93a$\xA4V[[_a%\xA1\x84\x82\x85\x01a%aV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a%\xFC\x82a%\xD3V[\x90P\x91\x90PV[a&\x0C\x81a%\xF2V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a&T\x82a&\x12V[a&^\x81\x85a&\x1CV[\x93Pa&n\x81\x85` \x86\x01a&,V[a&w\x81a&:V[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Qa&\x97_\x86\x01\x82a&\x03V[P` \x83\x01Q\x84\x82\x03` \x86\x01Ra&\xAF\x82\x82a&JV[\x91PP\x80\x91PP\x92\x91PPV[_a&\xC7\x83\x83a&\x82V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a&\xE5\x82a%\xAAV[a&\xEF\x81\x85a%\xB4V[\x93P\x83` \x82\x02\x85\x01a'\x01\x85a%\xC4V[\x80_[\x85\x81\x10\x15a'<W\x84\x84\x03\x89R\x81Qa'\x1D\x85\x82a&\xBCV[\x94Pa'(\x83a&\xCFV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa'\x04V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[a'W\x81a$\xE9V[\x82RPPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra'w\x82\x82a&\xDBV[\x91PP` \x83\x01Qa'\x8C` \x86\x01\x82a'NV[P\x80\x91PP\x92\x91PPV[a'\xA0\x81a$\xACV[\x82RPPV[_\x81\x90P\x91\x90PV[a'\xB8\x81a'\xA6V[\x82RPPV[`@\x82\x01_\x82\x01Qa'\xD2_\x85\x01\x82a'\x97V[P` \x82\x01Qa'\xE5` \x85\x01\x82a'\xAFV[PPPPV[` \x82\x01_\x82\x01Qa'\xFF_\x85\x01\x82a&\x03V[PPPPV[_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a()\x81a(\x05V[\x82RPPV[_`\xE0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra(I\x82\x82a']V[\x91PP` \x83\x01Qa(^` \x86\x01\x82a'\xBEV[P`@\x83\x01Q\x84\x82\x03``\x86\x01Ra(v\x82\x82a']V[\x91PP``\x83\x01Qa(\x8B`\x80\x86\x01\x82a'\xEBV[P`\x80\x83\x01Qa(\x9E`\xA0\x86\x01\x82a'\x97V[P`\xA0\x83\x01Qa(\xB1`\xC0\x86\x01\x82a( V[P\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(\xD4\x81\x84a(/V[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a(\xFDWa(\xFCa(\xDCV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\x1AWa)\x19a(\xE0V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a)6Wa)5a(\xE4V[[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a)SWa)Ra$\xA4V[[_\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)pWa)oa$\xA8V[[a)|\x85\x82\x86\x01a(\xE8V[\x92P\x92PP\x92P\x92\x90PV[_`@\x82\x84\x03\x12\x15a)\x9DWa)\x9Ca%]V[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\xBBWa)\xBAa$\xA4V[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\xD8Wa)\xD7a$\xA8V[[a)\xE4\x84\x82\x85\x01a)\x88V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a*\x02Wa*\x01a$\xA4V[[_a*\x0F\x84\x82\x85\x01a%\x0BV[\x91PP\x92\x91PPV[___`@\x84\x86\x03\x12\x15a*/Wa*.a$\xA4V[[_a*<\x86\x82\x87\x01a%\x0BV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*]Wa*\\a$\xA8V[[a*i\x86\x82\x87\x01a(\xE8V[\x92P\x92PP\x92P\x92P\x92V[a*~\x81a%\xF2V[\x81\x14a*\x88W__\xFD[PV[_\x815\x90Pa*\x99\x81a*uV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a*\xB4Wa*\xB3a$\xA4V[[_a*\xC1\x84\x82\x85\x01a*\x8BV[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fnot the owner\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+\x0E`\r\x83a*\xCAV[\x91Pa+\x19\x82a*\xDAV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+;\x81a+\x02V[\x90P\x91\x90PV[\x7Fno maintenance\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+v`\x0E\x83a*\xCAV[\x91Pa+\x81\x82a+BV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+\xA3\x81a+jV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a+\xE1\x82a(\x05V[\x91Po\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a,\x03Wa,\x02a+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[a,\x17\x81a(\x05V[\x82RPPV[_` \x82\x01\x90Pa,0_\x83\x01\x84a,\x0EV[\x92\x91PPV[\x7Fno migration\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,j`\x0C\x83a*\xCAV[\x91Pa,u\x82a,6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x97\x81a,^V[\x90P\x91\x90PV[\x7Fwrong migration id\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xD2`\x12\x83a*\xCAV[\x91Pa,\xDD\x82a,\x9EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xFF\x81a,\xC6V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a-=\x82a$\xACV[\x91Pa-H\x83a$\xACV[\x92P\x82a-XWa-Wa-\x06V[[\x82\x82\x06\x90P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Fwrong operator\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-\xC4`\x0E\x83a*\xCAV[\x91Pa-\xCF\x82a-\x90V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xF1\x81a-\xB8V[\x90P\x91\x90PV[a.\x01\x81a$\xACV[\x82RPPV[a.\x10\x81a%\xF2V[\x82RPPV[_``\x82\x01\x90Pa.)_\x83\x01\x86a-\xF8V[a.6` \x83\x01\x85a.\x07V[a.C`@\x83\x01\x84a,\x0EV[\x94\x93PPPPV[_a\xFF\xFF\x82\x16\x90P\x91\x90PV[a.a\x81a.KV[\x81\x14a.kW__\xFD[PV[_\x815a.z\x81a.XV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_a\xFF\xFFa.\x9B\x84a.\x83V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a.\xD4a.\xCFa.\xCA\x84a.KV[a.\xB1V[a.KV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a.\xED\x82a.\xBAV[a/\0a.\xF9\x82a.\xDBV[\x83Ta.\x8EV[\x82UPPPV[_\x81\x01_\x83\x01\x80a/\x17\x81a.nV[\x90Pa/#\x81\x84a.\xE4V[PPPPPV[a/4\x82\x82a/\x07V[PPV[_a/B\x82a$\xACV[\x91Pa/M\x83a$\xACV[\x92P\x82\x82\x03\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a/mWa/la+\xAAV[[\x92\x91PPV[_a/}\x82a'\xA6V[\x91Pa/\x88\x83a'\xA6V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a/\xA0Wa/\x9Fa+\xAAV[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a0\x17W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a0*Wa0)a/\xD3V[[P\x91\x90PV[_a0:\x82a'\xA6V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a0lWa0ka+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a0\xDD\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a0\xA2V[a0\xE7\x86\x83a0\xA2V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_a1\x19a1\x14a1\x0F\x84a'\xA6V[a.\xB1V[a'\xA6V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a12\x83a0\xFFV[a1Fa1>\x82a1 V[\x84\x84Ta0\xAEV[\x82UPPPPV[__\x90P\x90V[a1]a1NV[a1h\x81\x84\x84a1)V[PPPV[[\x81\x81\x10\x15a1\x8BWa1\x80_\x82a1UV[`\x01\x81\x01\x90Pa1nV[PPV[`\x1F\x82\x11\x15a1\xD0Wa1\xA1\x81a0\x81V[a1\xAA\x84a0\x93V[\x81\x01` \x85\x10\x15a1\xB9W\x81\x90P[a1\xCDa1\xC5\x85a0\x93V[\x83\x01\x82a1mV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a1\xF0_\x19\x84`\x08\x02a1\xD5V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a2\x08\x83\x83a1\xE1V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a2\"\x83\x83a0wV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a2;Wa2:a/\xA6V[[a2E\x82Ta0\0V[a2P\x82\x82\x85a1\x8FV[_`\x1F\x83\x11`\x01\x81\x14a2}W_\x84\x15a2kW\x82\x87\x015\x90P[a2u\x85\x82a1\xFDV[\x86UPa2\xDCV[`\x1F\x19\x84\x16a2\x8B\x86a0\x81V[_[\x82\x81\x10\x15a2\xB2W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa2\x8DV[\x86\x83\x10\x15a2\xCFW\x84\x89\x015a2\xCB`\x1F\x89\x16\x82a1\xE1V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pa2\xF8_\x83\x01\x85a.\x07V[a3\x05` \x83\x01\x84a,\x0EV[\x93\x92PPPV[_a3\x16\x82a$\xACV[\x91P_\x82\x03a3(Wa3'a+\xAAV[[`\x01\x82\x03\x90P\x91\x90PV[_`@\x82\x01\x90Pa3F_\x83\x01\x85a-\xF8V[a3S` \x83\x01\x84a,\x0EV[\x93\x92PPPV[\x7Fmigration in progress\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a3\x8E`\x15\x83a*\xCAV[\x91Pa3\x99\x82a3ZV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\xBB\x81a3\x82V[\x90P\x91\x90PV[\x7Fmaintenance in progress\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a3\xF6`\x17\x83a*\xCAV[\x91Pa4\x01\x82a3\xC2V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra4#\x81a3\xEAV[\x90P\x91\x90PV[_a44\x82a$\xACV[\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a4NWa4Ma+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a4\x81Wa4\x80a4YV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xA3Wa4\xA2a4]V[[` \x83\x01\x92P`@\x82\x026\x03\x83\x13\x15a4\xBFWa4\xBEa4aV[[P\x92P\x92\x90PV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a4\xEFWa4\xEEa4\xCFV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a5\x17Wa5\x16a4\xC7V[[`@\x82\x026\x03\x83\x13\x15a5-Wa5,a4\xCBV[[P\x92P\x92\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[_a5\\` \x84\x01\x84a%\x0BV[\x90P\x92\x91PPV[_a5r` \x84\x01\x84a*\x8BV[\x90P\x92\x91PPV[`@\x82\x01a5\x8A_\x83\x01\x83a5NV[a5\x96_\x85\x01\x82a'NV[Pa5\xA4` \x83\x01\x83a5dV[a5\xB1` \x85\x01\x82a&\x03V[PPPPV[_a5\xC2\x83\x83a5zV[`@\x83\x01\x90P\x92\x91PPV[_\x82\x90P\x92\x91PPV[_`@\x82\x01\x90P\x91\x90PV[_a5\xEF\x83\x85a55V[\x93Pa5\xFA\x82a5EV[\x80_[\x85\x81\x10\x15a62Wa6\x0F\x82\x84a5\xCEV[a6\x19\x88\x82a5\xB7V[\x97Pa6$\x83a5\xD8V[\x92PP`\x01\x81\x01\x90Pa5\xFDV[P\x85\x92PPP\x93\x92PPPV[_`@\x83\x01a6P_\x84\x01\x84a4\xD3V[\x85\x83\x03_\x87\x01Ra6b\x83\x82\x84a5\xE4V[\x92PPPa6s` \x84\x01\x84a5NV[a6\x80` \x86\x01\x82a'NV[P\x80\x91PP\x92\x91PPV[_``\x82\x01\x90Pa6\x9E_\x83\x01\x86a-\xF8V[\x81\x81\x03` \x83\x01Ra6\xB0\x81\x85a6?V[\x90Pa6\xBF`@\x83\x01\x84a,\x0EV[\x94\x93PPPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x837_\x83\x83\x01RPPPV[_a6\xF0\x83\x85a6\xC7V[\x93Pa6\xFD\x83\x85\x84a6\xD7V[a7\x06\x83a&:V[\x84\x01\x90P\x93\x92PPPV[_``\x82\x01\x90Pa7$_\x83\x01\x87a.\x07V[\x81\x81\x03` \x83\x01Ra77\x81\x85\x87a6\xE5V[\x90Pa7F`@\x83\x01\x84a,\x0EV[\x95\x94PPPPPV[\x7Fempty operator data\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\x83`\x13\x83a*\xCAV[\x91Pa7\x8E\x82a7OV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra7\xB0\x81a7wV[\x90P\x91\x90PV[\x7Foperator data too large\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\xEB`\x17\x83a*\xCAV[\x91Pa7\xF6\x82a7\xB7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra8\x18\x81a7\xDFV[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \xFA\x04\xDE\xADB^j\xA2\xEEQe+w\xCD\x8B\xEC4O\x89\xD5\xA5\xD1\x8BB\xF4\x88\x9Bz\xBA\xD1s\"dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106100a7575f3560e01c8063ad36e6d01161006f578063ad36e6d014610127578063c130809a14610131578063cdbfc62d1461013b578063dd3fd26914610157578063f019b15414610173578063f2fde38b1461018f576100a7565b80633048bfba146100ab57806355a47d0a146100b557806365706f9c146100d157806375418b9d146100ed5780638b5252d61461010b575b5f5ffd5b6100b36101ab565b005b6100cf60048036038101906100ca919061251f565b61037f565b005b6100eb60048036038101906100e6919061257f565b6106bd565b005b6100f5610761565b60405161010291906128bc565b60405180910390f35b6101256004803603810190610120919061293d565b610f8f565b005b61012f610fec565b005b6101396111c6565b005b610155600480360381019061015091906129a6565b6113c9565b005b610171600480360381019061016c91906129ed565b611a99565b005b61018d60048036038101906101889190612a18565b611d15565b005b6101a960048036038101906101a49190612a9f565b6120ab565b005b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610239576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161023090612b24565b60405180910390fd5b61024161217b565b610280576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161027790612b8c565b60405180910390fd5b5f61020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff16809291906102f190612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f8fb9cd054d0a022110cced239e908b834e4cd219511856d4eaae3051d932d60461020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516103759190612c1d565b60405180910390a1565b6103876121d5565b6103c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103bd90612c80565b60405180910390fd5b6102085f015f9054906101000a900467ffffffffffffffff1667ffffffffffffffff168267ffffffffffffffff1614610434576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042b90612ce8565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff1661046f9190612d33565b67ffffffffffffffff166002811061048a57610489612d63565b5b61010202015f018260ff1661010081106104a7576104a6612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461051e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161051590612dda565b60405180910390fd5b61053781610208600101546121e590919063ffffffff16565b6106b95761055481610208600101546121fa90919063ffffffff16565b6102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061058c90612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550505f6102086001015403610646577f01269879535f40ee8957e15e160bf1866c5e2728ff0cbc583d848821e2639b4e6102085f015f9054906101000a900467ffffffffffffffff163361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff1660405161063993929190612e16565b60405180910390a16106b8565b7faf5e90e72015f43138f66b4cd08bd1dfa2839030104f22a00af843fe847c6d196102085f015f9054906101000a900467ffffffffffffffff163361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516106af93929190612e16565b60405180910390a15b5b5050565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161074290612b24565b60405180910390fd5b80610207818161075b9190612f2a565b90505050565b6107696123a7565b6107716123a7565b5f5f5f61077c6121d5565b15610bb9576102085f015f9054906101000a900467ffffffffffffffff1684602001515f019067ffffffffffffffff16908167ffffffffffffffff16815250506102086001015484602001516020018181525050600260016102065f9054906101000a900467ffffffffffffffff166107f59190612f38565b6107ff9190612d33565b67ffffffffffffffff1692505f60026102065f9054906101000a900467ffffffffffffffff1661082f9190612d33565b67ffffffffffffffff1690506108616002826002811061085257610851612d63565b5b6101020201610100015461220e565b91506001826108709190612f73565b67ffffffffffffffff81111561088957610888612fa6565b5b6040519080825280602002602001820160405280156108c257816020015b6108af61240f565b8152602001906001900390816108a75790505b5085604001515f0181905250600281600281106108e2576108e1612d63565b5b6101020201610101015f9054906101000a900460ff1685604001516020019060ff16908160ff16815250505f5f90505b828111610bb257610949816002846002811061093157610930612d63565b5b610102020161010001546121e590919063ffffffff16565b610b9f576002826002811061096157610960612d63565b5b61010202015f0181610100811061097b5761097a612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1693508386604001515f015182815181106109b9576109b8612d63565b5b60200260200101515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050610a268160028760028110610a0e57610a0d612d63565b5b610102020161010001546121e590919063ffffffff16565b80610aab57508373ffffffffffffffffffffffffffffffffffffffff1660028660028110610a5757610a56612d63565b5b61010202015f01826101008110610a7157610a70612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b15610b9e5760015f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208054610af890613000565b80601f0160208091040260200160405190810160405280929190818152602001828054610b2490613000565b8015610b6f5780601f10610b4657610100808354040283529160200191610b6f565b820191905f5260205f20905b815481529060010190602001808311610b5257829003601f168201915b505050505086604001515f01518281518110610b8e57610b8d612d63565b5b6020026020010151602001819052505b5b8080610baa90613030565b915050610912565b5050610be9565b60026102065f9054906101000a900467ffffffffffffffff16610bdc9190612d33565b67ffffffffffffffff1692505b610c0f60028460028110610c0057610bff612d63565b5b6101020201610100015461220e565b9050600181610c1e9190612f73565b67ffffffffffffffff811115610c3757610c36612fa6565b5b604051908082528060200260200182016040528015610c7057816020015b610c5d61240f565b815260200190600190039081610c555790505b50845f01515f018190525060028360028110610c8f57610c8e612d63565b5b6101020201610101015f9054906101000a900460ff16845f01516020019060ff16908160ff16815250505f5f90505b818111610ea157610cf58160028660028110610cdd57610cdc612d63565b5b610102020161010001546121e590919063ffffffff16565b610e8e5760028460028110610d0d57610d0c612d63565b5b61010202015f01816101008110610d2757610d26612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16925082855f01515f01518281518110610d6457610d63612d63565b5b60200260200101515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060015f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f208054610de990613000565b80601f0160208091040260200160405190810160405280929190818152602001828054610e1590613000565b8015610e605780601f10610e3757610100808354040283529160200191610e60565b820191905f5260205f20905b815481529060010190602001808311610e4357829003601f168201915b5050505050855f01515f01518281518110610e7e57610e7d612d63565b5b6020026020010151602001819052505b8080610e9990613030565b915050610cbe565b506102065f9054906101000a900467ffffffffffffffff16846080019067ffffffffffffffff16908167ffffffffffffffff168152505061020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684606001515f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061020b5f9054906101000a90046fffffffffffffffffffffffffffffffff168460a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508394505050505090565b610f9b8282905061221f565b818160015f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209182610fe7929190613218565b505050565b610ff461217b565b611033576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161102a90612b8c565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff1661020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146110c5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110bc90612dda565b60405180910390fd5b5f61020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061113690612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507ff91067eb420c28d3124865fc996e6aa9d541b9b4fef9188cb965a6cc6491638e3361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516111bc9291906132e5565b60405180910390a1565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611254576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161124b90612b24565b60405180910390fd5b61125c6121d5565b61129b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161129290612c80565b60405180910390fd5b6102065f81819054906101000a900467ffffffffffffffff16809291906112c19061330c565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f6102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061132190612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507ff73240422246f63ed633ef3ce0726b8ab8fb69d46c8a4e5ecb0b2922668674a16102085f015f9054906101000a900467ffffffffffffffff1661020b5f9054906101000a90046fffffffffffffffffffffffffffffffff166040516113bf929190613333565b60405180910390a1565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611457576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161144e90612b24565b60405180910390fd5b61145f6121d5565b1561149f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611496906133a4565b60405180910390fd5b6114a761217b565b156114e7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114de9061340c565b60405180910390fd5b6102085f015f81819054906101000a900467ffffffffffffffff168092919061150f9061342a565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f60026102065f9054906101000a900467ffffffffffffffff1661155a9190612d33565b67ffffffffffffffff1690506102065f81819054906101000a900467ffffffffffffffff168092919061158c9061342a565b91906101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550505f60026102065f9054906101000a900467ffffffffffffffff166115d79190612d33565b67ffffffffffffffff1690505f5f90505b61160e600284600281106115ff576115fe612d63565b5b6101020201610100015461220e565b81116117b2576002836002811061162857611627612d63565b5b61010202015f0181610100811061164257611641612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166002836002811061168d5761168c612d63565b5b61010202015f018261010081106116a7576116a6612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461179f57600283600281106116f7576116f6612d63565b5b61010202015f0181610100811061171157611710612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff166002836002811061174657611745612d63565b5b61010202015f018261010081106117605761175f612d63565b5b015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b80806117aa90613030565b9150506115e8565b505f600283600281106117c8576117c7612d63565b5b6101020201610100015490505f5f5f5f90505b86805f01906117ea9190613465565b90508110156119465786805f01906118029190613465565b8281811061181357611812612d63565b5b9050604002015f01602081019061182a91906129ed565b925086805f019061183b9190613465565b8281811061184c5761184b612d63565b5b90506040020160200160208101906118649190612a9f565b91505f73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036118b3576118ac83856121fa90919063ffffffff16565b93506118c9565b6118c683856122bd90919063ffffffff16565b93505b81600286600281106118de576118dd612d63565b5b61010202015f018460ff1661010081106118fb576118fa612d63565b5b015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080806001019150506117db565b50826002856002811061195c5761195b612d63565b5b6101020201610100018190555085602001602081019061197c91906129ed565b600285600281106119905761198f612d63565b5b6101020201610101015f6101000a81548160ff021916908360ff160217905550826102086001018190555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff16809291906119e990612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f78dad2bc0b47c688ed84f3fee79abc18e6c9822db05a79ca19dff54533c7470d6102085f015f9054906101000a900467ffffffffffffffff168761020b5f9054906101000a90046fffffffffffffffffffffffffffffffff16604051611a899392919061368b565b60405180910390a1505050505050565b611aa16121d5565b15611ae1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ad8906133a4565b60405180910390fd5b611ae961217b565b15611b29576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b209061340c565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611b649190612d33565b67ffffffffffffffff1660028110611b7f57611b7e612d63565b5b61010202015f018260ff166101008110611b9c57611b9b612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614611c13576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c0a90612dda565b60405180910390fd5b3361020a5f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff1680929190611c8490612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507fbc2748cf02f7a1291525e866efc76ab3b96d32d7afcbb26c53daec617b38b4793361020b5f9054906101000a90046fffffffffffffffffffffffffffffffff16604051611d0a9291906132e5565b60405180910390a150565b611d218282905061221f565b5f5f611d2b6121d5565b15611ea1573373ffffffffffffffffffffffffffffffffffffffff1660028060016102065f9054906101000a900467ffffffffffffffff16611d6d9190612f38565b611d779190612d33565b67ffffffffffffffff1660028110611d9257611d91612d63565b5b61010202015f018660ff166101008110611daf57611dae612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614915081611e9c573373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611e299190612d33565b67ffffffffffffffff1660028110611e4457611e43612d63565b5b61010202015f018660ff166101008110611e6157611e60612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161490505b611f4f565b3373ffffffffffffffffffffffffffffffffffffffff166002806102065f9054906101000a900467ffffffffffffffff16611edc9190612d33565b67ffffffffffffffff1660028110611ef757611ef6612d63565b5b61010202015f018660ff166101008110611f1457611f13612d63565b5b015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161491505b8180611f585750805b611f97576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f8e90612dda565b60405180910390fd5b838360015f3373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f209182611fe3929190613218565b5061020b5f81819054906101000a90046fffffffffffffffffffffffffffffffff168092919061201290612bd7565b91906101000a8154816fffffffffffffffffffffffffffffffff02191690836fffffffffffffffffffffffffffffffff160217905550507f125181ec21882dec51a2392905dff3a82cbd0262f18b5c0c035488671b40afb233858561020b5f9054906101000a90046fffffffffffffffffffffffffffffffff1660405161209c9493929190613711565b60405180910390a15050505050565b5f5f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612139576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161213090612b24565b60405180910390fd5b805f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b5f5f73ffffffffffffffffffffffffffffffffffffffff1661020a5f015f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415905090565b5f5f610208600101541415905090565b5f5f8260ff166001901b841614905092915050565b5f8160ff166001901b198316905092915050565b5f612218826122d0565b9050919050565b5f8111612261576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161225890613799565b60405180910390fd5b6102075f015f9054906101000a900461ffff1661ffff168111156122ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016122b190613801565b60405180910390fd5b50565b5f8160ff166001901b8317905092915050565b5f60076122ee6fffffffffffffffffffffffffffffffff841161239c565b901b9050600661230a67ffffffffffffffff8385901c1161239c565b901b81179050600561232463ffffffff8385901c1161239c565b901b81179050600461233c61ffff8385901c1161239c565b901b81179050600361235360ff8385901c1161239c565b901b81179050600261236a600f8385901c1161239c565b901b811790507d01010202020203030303030303030000000000000000000000000000000082821c1a81179050919050565b5f8115159050919050565b6040518060c001604052806123ba61243e565b81526020016123c761245a565b81526020016123d461243e565b81526020016123e161247c565b81526020015f67ffffffffffffffff1681526020015f6fffffffffffffffffffffffffffffffff1681525090565b60405180604001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060400160405280606081526020015f60ff1681525090565b60405180604001604052805f67ffffffffffffffff1681526020015f81525090565b60405180602001604052805f73ffffffffffffffffffffffffffffffffffffffff1681525090565b5f5ffd5b5f5ffd5b5f67ffffffffffffffff82169050919050565b6124c8816124ac565b81146124d2575f5ffd5b50565b5f813590506124e3816124bf565b92915050565b5f60ff82169050919050565b6124fe816124e9565b8114612508575f5ffd5b50565b5f81359050612519816124f5565b92915050565b5f5f60408385031215612535576125346124a4565b5b5f612542858286016124d5565b92505060206125538582860161250b565b9150509250929050565b5f5ffd5b5f602082840312156125765761257561255d565b5b81905092915050565b5f60208284031215612594576125936124a4565b5b5f6125a184828501612561565b91505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6125fc826125d3565b9050919050565b61260c816125f2565b82525050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f61265482612612565b61265e818561261c565b935061266e81856020860161262c565b6126778161263a565b840191505092915050565b5f604083015f8301516126975f860182612603565b50602083015184820360208601526126af828261264a565b9150508091505092915050565b5f6126c78383612682565b905092915050565b5f602082019050919050565b5f6126e5826125aa565b6126ef81856125b4565b935083602082028501612701856125c4565b805f5b8581101561273c578484038952815161271d85826126bc565b9450612728836126cf565b925060208a01995050600181019050612704565b50829750879550505050505092915050565b612757816124e9565b82525050565b5f604083015f8301518482035f86015261277782826126db565b915050602083015161278c602086018261274e565b508091505092915050565b6127a0816124ac565b82525050565b5f819050919050565b6127b8816127a6565b82525050565b604082015f8201516127d25f850182612797565b5060208201516127e560208501826127af565b50505050565b602082015f8201516127ff5f850182612603565b50505050565b5f6fffffffffffffffffffffffffffffffff82169050919050565b61282981612805565b82525050565b5f60e083015f8301518482035f860152612849828261275d565b915050602083015161285e60208601826127be565b5060408301518482036060860152612876828261275d565b915050606083015161288b60808601826127eb565b50608083015161289e60a0860182612797565b5060a08301516128b160c0860182612820565b508091505092915050565b5f6020820190508181035f8301526128d4818461282f565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126128fd576128fc6128dc565b5b8235905067ffffffffffffffff81111561291a576129196128e0565b5b602083019150836001820283011115612936576129356128e4565b5b9250929050565b5f5f60208385031215612953576129526124a4565b5b5f83013567ffffffffffffffff8111156129705761296f6124a8565b5b61297c858286016128e8565b92509250509250929050565b5f6040828403121561299d5761299c61255d565b5b81905092915050565b5f602082840312156129bb576129ba6124a4565b5b5f82013567ffffffffffffffff8111156129d8576129d76124a8565b5b6129e484828501612988565b91505092915050565b5f60208284031215612a0257612a016124a4565b5b5f612a0f8482850161250b565b91505092915050565b5f5f5f60408486031215612a2f57612a2e6124a4565b5b5f612a3c8682870161250b565b935050602084013567ffffffffffffffff811115612a5d57612a5c6124a8565b5b612a69868287016128e8565b92509250509250925092565b612a7e816125f2565b8114612a88575f5ffd5b50565b5f81359050612a9981612a75565b92915050565b5f60208284031215612ab457612ab36124a4565b5b5f612ac184828501612a8b565b91505092915050565b5f82825260208201905092915050565b7f6e6f7420746865206f776e6572000000000000000000000000000000000000005f82015250565b5f612b0e600d83612aca565b9150612b1982612ada565b602082019050919050565b5f6020820190508181035f830152612b3b81612b02565b9050919050565b7f6e6f206d61696e74656e616e63650000000000000000000000000000000000005f82015250565b5f612b76600e83612aca565b9150612b8182612b42565b602082019050919050565b5f6020820190508181035f830152612ba381612b6a565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612be182612805565b91506fffffffffffffffffffffffffffffffff8203612c0357612c02612baa565b5b600182019050919050565b612c1781612805565b82525050565b5f602082019050612c305f830184612c0e565b92915050565b7f6e6f206d6967726174696f6e00000000000000000000000000000000000000005f82015250565b5f612c6a600c83612aca565b9150612c7582612c36565b602082019050919050565b5f6020820190508181035f830152612c9781612c5e565b9050919050565b7f77726f6e67206d6967726174696f6e20696400000000000000000000000000005f82015250565b5f612cd2601283612aca565b9150612cdd82612c9e565b602082019050919050565b5f6020820190508181035f830152612cff81612cc6565b9050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f612d3d826124ac565b9150612d48836124ac565b925082612d5857612d57612d06565b5b828206905092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f77726f6e67206f70657261746f720000000000000000000000000000000000005f82015250565b5f612dc4600e83612aca565b9150612dcf82612d90565b602082019050919050565b5f6020820190508181035f830152612df181612db8565b9050919050565b612e01816124ac565b82525050565b612e10816125f2565b82525050565b5f606082019050612e295f830186612df8565b612e366020830185612e07565b612e436040830184612c0e565b949350505050565b5f61ffff82169050919050565b612e6181612e4b565b8114612e6b575f5ffd5b50565b5f8135612e7a81612e58565b80915050919050565b5f815f1b9050919050565b5f61ffff612e9b84612e83565b9350801983169250808416831791505092915050565b5f819050919050565b5f612ed4612ecf612eca84612e4b565b612eb1565b612e4b565b9050919050565b5f819050919050565b612eed82612eba565b612f00612ef982612edb565b8354612e8e565b8255505050565b5f81015f830180612f1781612e6e565b9050612f238184612ee4565b5050505050565b612f348282612f07565b5050565b5f612f42826124ac565b9150612f4d836124ac565b9250828203905067ffffffffffffffff811115612f6d57612f6c612baa565b5b92915050565b5f612f7d826127a6565b9150612f88836127a6565b9250828201905080821115612fa057612f9f612baa565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f600282049050600182168061301757607f821691505b60208210810361302a57613029612fd3565b5b50919050565b5f61303a826127a6565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361306c5761306b612baa565b5b600182019050919050565b5f82905092915050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026130dd7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826130a2565b6130e786836130a2565b95508019841693508086168417925050509392505050565b5f61311961311461310f846127a6565b612eb1565b6127a6565b9050919050565b5f819050919050565b613132836130ff565b61314661313e82613120565b8484546130ae565b825550505050565b5f5f905090565b61315d61314e565b613168818484613129565b505050565b5b8181101561318b576131805f82613155565b60018101905061316e565b5050565b601f8211156131d0576131a181613081565b6131aa84613093565b810160208510156131b9578190505b6131cd6131c585613093565b83018261316d565b50505b505050565b5f82821c905092915050565b5f6131f05f19846008026131d5565b1980831691505092915050565b5f61320883836131e1565b9150826002028217905092915050565b6132228383613077565b67ffffffffffffffff81111561323b5761323a612fa6565b5b6132458254613000565b61325082828561318f565b5f601f83116001811461327d575f841561326b578287013590505b61327585826131fd565b8655506132dc565b601f19841661328b86613081565b5f5b828110156132b25784890135825560018201915060208501945060208101905061328d565b868310156132cf57848901356132cb601f8916826131e1565b8355505b6001600288020188555050505b50505050505050565b5f6040820190506132f85f830185612e07565b6133056020830184612c0e565b9392505050565b5f613316826124ac565b91505f820361332857613327612baa565b5b600182039050919050565b5f6040820190506133465f830185612df8565b6133536020830184612c0e565b9392505050565b7f6d6967726174696f6e20696e2070726f677265737300000000000000000000005f82015250565b5f61338e601583612aca565b91506133998261335a565b602082019050919050565b5f6020820190508181035f8301526133bb81613382565b9050919050565b7f6d61696e74656e616e636520696e2070726f67726573730000000000000000005f82015250565b5f6133f6601783612aca565b9150613401826133c2565b602082019050919050565b5f6020820190508181035f830152613423816133ea565b9050919050565b5f613434826124ac565b915067ffffffffffffffff820361344e5761344d612baa565b5b600182019050919050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f8335600160200384360303811261348157613480613459565b5b80840192508235915067ffffffffffffffff8211156134a3576134a261345d565b5b6020830192506040820236038313156134bf576134be613461565b5b509250929050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f833560016020038436030381126134ef576134ee6134cf565b5b83810192508235915060208301925067ffffffffffffffff821115613517576135166134c7565b5b60408202360383131561352d5761352c6134cb565b5b509250929050565b5f82825260208201905092915050565b5f819050919050565b5f61355c602084018461250b565b905092915050565b5f6135726020840184612a8b565b905092915050565b6040820161358a5f83018361354e565b6135965f85018261274e565b506135a46020830183613564565b6135b16020850182612603565b50505050565b5f6135c2838361357a565b60408301905092915050565b5f82905092915050565b5f604082019050919050565b5f6135ef8385613535565b93506135fa82613545565b805f5b858110156136325761360f82846135ce565b61361988826135b7565b9750613624836135d8565b9250506001810190506135fd565b5085925050509392505050565b5f604083016136505f8401846134d3565b8583035f8701526136628382846135e4565b92505050613673602084018461354e565b613680602086018261274e565b508091505092915050565b5f60608201905061369e5f830186612df8565b81810360208301526136b0818561363f565b90506136bf6040830184612c0e565b949350505050565b5f82825260208201905092915050565b828183375f83830152505050565b5f6136f083856136c7565b93506136fd8385846136d7565b6137068361263a565b840190509392505050565b5f6060820190506137245f830187612e07565b81810360208301526137378185876136e5565b90506137466040830184612c0e565b95945050505050565b7f656d707479206f70657261746f722064617461000000000000000000000000005f82015250565b5f613783601383612aca565b915061378e8261374f565b602082019050919050565b5f6020820190508181035f8301526137b081613777565b9050919050565b7f6f70657261746f72206461746120746f6f206c617267650000000000000000005f82015250565b5f6137eb601783612aca565b91506137f6826137b7565b602082019050919050565b5f6020820190508181035f830152613818816137df565b905091905056fea2646970667358221220fa04dead425e6aa2ee51652b77cd8bec344f89d5a5d18b42f4889b7abad1732264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\xA7W_5`\xE0\x1C\x80c\xAD6\xE6\xD0\x11a\0oW\x80c\xAD6\xE6\xD0\x14a\x01'W\x80c\xC10\x80\x9A\x14a\x011W\x80c\xCD\xBF\xC6-\x14a\x01;W\x80c\xDD?\xD2i\x14a\x01WW\x80c\xF0\x19\xB1T\x14a\x01sW\x80c\xF2\xFD\xE3\x8B\x14a\x01\x8FWa\0\xA7V[\x80c0H\xBF\xBA\x14a\0\xABW\x80cU\xA4}\n\x14a\0\xB5W\x80cepo\x9C\x14a\0\xD1W\x80cuA\x8B\x9D\x14a\0\xEDW\x80c\x8BRR\xD6\x14a\x01\x0BW[__\xFD[a\0\xB3a\x01\xABV[\0[a\0\xCF`\x04\x806\x03\x81\x01\x90a\0\xCA\x91\x90a%\x1FV[a\x03\x7FV[\0[a\0\xEB`\x04\x806\x03\x81\x01\x90a\0\xE6\x91\x90a%\x7FV[a\x06\xBDV[\0[a\0\xF5a\x07aV[`@Qa\x01\x02\x91\x90a(\xBCV[`@Q\x80\x91\x03\x90\xF3[a\x01%`\x04\x806\x03\x81\x01\x90a\x01 \x91\x90a)=V[a\x0F\x8FV[\0[a\x01/a\x0F\xECV[\0[a\x019a\x11\xC6V[\0[a\x01U`\x04\x806\x03\x81\x01\x90a\x01P\x91\x90a)\xA6V[a\x13\xC9V[\0[a\x01q`\x04\x806\x03\x81\x01\x90a\x01l\x91\x90a)\xEDV[a\x1A\x99V[\0[a\x01\x8D`\x04\x806\x03\x81\x01\x90a\x01\x88\x91\x90a*\x18V[a\x1D\x15V[\0[a\x01\xA9`\x04\x806\x03\x81\x01\x90a\x01\xA4\x91\x90a*\x9FV[a \xABV[\0[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x029W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x020\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x02Aa!{V[a\x02\x80W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x02w\x90a+\x8CV[`@Q\x80\x91\x03\x90\xFD[_a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x02\xF1\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\x8F\xB9\xCD\x05M\n\x02!\x10\xCC\xED#\x9E\x90\x8B\x83NL\xD2\x19Q\x18V\xD4\xEA\xAE0Q\xD92\xD6\x04a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x03u\x91\x90a,\x1DV[`@Q\x80\x91\x03\x90\xA1V[a\x03\x87a!\xD5V[a\x03\xC6W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x03\xBD\x90a,\x80V[`@Q\x80\x91\x03\x90\xFD[a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x044W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x04+\x90a,\xE8V[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x04o\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x04\x8AWa\x04\x89a-cV[[a\x01\x02\x02\x01_\x01\x82`\xFF\x16a\x01\0\x81\x10a\x04\xA7Wa\x04\xA6a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x05\x1EW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05\x15\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[a\x057\x81a\x02\x08`\x01\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x06\xB9Wa\x05T\x81a\x02\x08`\x01\x01Ta!\xFA\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x05\x8C\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_a\x02\x08`\x01\x01T\x03a\x06FW\x7F\x01&\x98yS_@\xEE\x89W\xE1^\x16\x0B\xF1\x86l^'(\xFF\x0C\xBCX=\x84\x88!\xE2c\x9BNa\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x069\x93\x92\x91\x90a.\x16V[`@Q\x80\x91\x03\x90\xA1a\x06\xB8V[\x7F\xAF^\x90\xE7 \x15\xF418\xF6kL\xD0\x8B\xD1\xDF\xA2\x83\x900\x10O\"\xA0\n\xF8C\xFE\x84|m\x19a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x06\xAF\x93\x92\x91\x90a.\x16V[`@Q\x80\x91\x03\x90\xA1[[PPV[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x07KW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x07B\x90a+$V[`@Q\x80\x91\x03\x90\xFD[\x80a\x02\x07\x81\x81a\x07[\x91\x90a/*V[\x90PPPV[a\x07ia#\xA7V[a\x07qa#\xA7V[___a\x07|a!\xD5V[\x15a\x0B\xB9Wa\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84` \x01Q_\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\x08`\x01\x01T\x84` \x01Q` \x01\x81\x81RPP`\x02`\x01a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xF5\x91\x90a/8V[a\x07\xFF\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x08/\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90Pa\x08a`\x02\x82`\x02\x81\x10a\x08RWa\x08Qa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x91P`\x01\x82a\x08p\x91\x90a/sV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x08\x89Wa\x08\x88a/\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\xC2W\x81` \x01[a\x08\xAFa$\x0FV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x08\xA7W\x90P[P\x85`@\x01Q_\x01\x81\x90RP`\x02\x81`\x02\x81\x10a\x08\xE2Wa\x08\xE1a-cV[[a\x01\x02\x02\x01a\x01\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x85`@\x01Q` \x01\x90`\xFF\x16\x90\x81`\xFF\x16\x81RPP__\x90P[\x82\x81\x11a\x0B\xB2Wa\tI\x81`\x02\x84`\x02\x81\x10a\t1Wa\t0a-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x0B\x9FW`\x02\x82`\x02\x81\x10a\taWa\t`a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\t{Wa\tza-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93P\x83\x86`@\x01Q_\x01Q\x82\x81Q\x81\x10a\t\xB9Wa\t\xB8a-cV[[` \x02` \x01\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\n&\x81`\x02\x87`\x02\x81\x10a\n\x0EWa\n\ra-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80a\n\xABWP\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x86`\x02\x81\x10a\nWWa\nVa-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\nqWa\npa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15[\x15a\x0B\x9EW`\x01_\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x80Ta\n\xF8\x90a0\0V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B$\x90a0\0V[\x80\x15a\x0BoW\x80`\x1F\x10a\x0BFWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BoV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0BRW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x86`@\x01Q_\x01Q\x82\x81Q\x81\x10a\x0B\x8EWa\x0B\x8Da-cV[[` \x02` \x01\x01Q` \x01\x81\x90RP[[\x80\x80a\x0B\xAA\x90a00V[\x91PPa\t\x12V[PPa\x0B\xE9V[`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x0B\xDC\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P[a\x0C\x0F`\x02\x84`\x02\x81\x10a\x0C\0Wa\x0B\xFFa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x90P`\x01\x81a\x0C\x1E\x91\x90a/sV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x0C7Wa\x0C6a/\xA6V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0CpW\x81` \x01[a\x0C]a$\x0FV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x0CUW\x90P[P\x84_\x01Q_\x01\x81\x90RP`\x02\x83`\x02\x81\x10a\x0C\x8FWa\x0C\x8Ea-cV[[a\x01\x02\x02\x01a\x01\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x84_\x01Q` \x01\x90`\xFF\x16\x90\x81`\xFF\x16\x81RPP__\x90P[\x81\x81\x11a\x0E\xA1Wa\x0C\xF5\x81`\x02\x86`\x02\x81\x10a\x0C\xDDWa\x0C\xDCa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta!\xE5\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[a\x0E\x8EW`\x02\x84`\x02\x81\x10a\r\rWa\r\x0Ca-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\r'Wa\r&a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x92P\x82\x85_\x01Q_\x01Q\x82\x81Q\x81\x10a\rdWa\rca-cV[[` \x02` \x01\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP`\x01_\x84s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x80Ta\r\xE9\x90a0\0V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0E\x15\x90a0\0V[\x80\x15a\x0E`W\x80`\x1F\x10a\x0E7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0E`V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0ECW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x85_\x01Q_\x01Q\x82\x81Q\x81\x10a\x0E~Wa\x0E}a-cV[[` \x02` \x01\x01Q` \x01\x81\x90RP[\x80\x80a\x0E\x99\x90a00V[\x91PPa\x0C\xBEV[Pa\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`\x80\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84``\x01Q_\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPPa\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84`\xA0\x01\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RPP\x83\x94PPPPP\x90V[a\x0F\x9B\x82\x82\x90Pa\"\x1FV[\x81\x81`\x01_3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x91\x82a\x0F\xE7\x92\x91\x90a2\x18V[PPPV[a\x0F\xF4a!{V[a\x103W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10*\x90a+\x8CV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x10\xC5W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x10\xBC\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[_a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x116\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xF9\x10g\xEBB\x0C(\xD3\x12He\xFC\x99nj\xA9\xD5A\xB9\xB4\xFE\xF9\x18\x8C\xB9e\xA6\xCCd\x91c\x8E3a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x11\xBC\x92\x91\x90a2\xE5V[`@Q\x80\x91\x03\x90\xA1V[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x12TW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12K\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x12\\a!\xD5V[a\x12\x9BW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x12\x92\x90a,\x80V[`@Q\x80\x91\x03\x90\xFD[a\x02\x06_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x12\xC1\x90a3\x0CV[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x13!\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xF72@B\"F\xF6>\xD63\xEF<\xE0rk\x8A\xB8\xFBi\xD4l\x8AN^\xCB\x0B)\"f\x86t\xA1a\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x13\xBF\x92\x91\x90a33V[`@Q\x80\x91\x03\x90\xA1V[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x14WW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14N\x90a+$V[`@Q\x80\x91\x03\x90\xFD[a\x14_a!\xD5V[\x15a\x14\x9FW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\x96\x90a3\xA4V[`@Q\x80\x91\x03\x90\xFD[a\x14\xA7a!{V[\x15a\x14\xE7W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x14\xDE\x90a4\x0CV[`@Q\x80\x91\x03\x90\xFD[a\x02\x08_\x01_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x15\x0F\x90a4*V[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15Z\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90Pa\x02\x06_\x81\x81\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x15\x8C\x90a4*V[\x91\x90a\x01\0\n\x81T\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP_`\x02a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x15\xD7\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P__\x90P[a\x16\x0E`\x02\x84`\x02\x81\x10a\x15\xFFWa\x15\xFEa-cV[[a\x01\x02\x02\x01a\x01\0\x01Ta\"\x0EV[\x81\x11a\x17\xB2W`\x02\x83`\x02\x81\x10a\x16(Wa\x16'a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\x16BWa\x16Aa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x83`\x02\x81\x10a\x16\x8DWa\x16\x8Ca-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\x16\xA7Wa\x16\xA6a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x17\x9FW`\x02\x83`\x02\x81\x10a\x16\xF7Wa\x16\xF6a-cV[[a\x01\x02\x02\x01_\x01\x81a\x01\0\x81\x10a\x17\x11Wa\x17\x10a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x83`\x02\x81\x10a\x17FWa\x17Ea-cV[[a\x01\x02\x02\x01_\x01\x82a\x01\0\x81\x10a\x17`Wa\x17_a-cV[[\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP[\x80\x80a\x17\xAA\x90a00V[\x91PPa\x15\xE8V[P_`\x02\x83`\x02\x81\x10a\x17\xC8Wa\x17\xC7a-cV[[a\x01\x02\x02\x01a\x01\0\x01T\x90P____\x90P[\x86\x80_\x01\x90a\x17\xEA\x91\x90a4eV[\x90P\x81\x10\x15a\x19FW\x86\x80_\x01\x90a\x18\x02\x91\x90a4eV[\x82\x81\x81\x10a\x18\x13Wa\x18\x12a-cV[[\x90P`@\x02\x01_\x01` \x81\x01\x90a\x18*\x91\x90a)\xEDV[\x92P\x86\x80_\x01\x90a\x18;\x91\x90a4eV[\x82\x81\x81\x10a\x18LWa\x18Ka-cV[[\x90P`@\x02\x01` \x01` \x81\x01\x90a\x18d\x91\x90a*\x9FV[\x91P_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a\x18\xB3Wa\x18\xAC\x83\x85a!\xFA\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x93Pa\x18\xC9V[a\x18\xC6\x83\x85a\"\xBD\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x93P[\x81`\x02\x86`\x02\x81\x10a\x18\xDEWa\x18\xDDa-cV[[a\x01\x02\x02\x01_\x01\x84`\xFF\x16a\x01\0\x81\x10a\x18\xFBWa\x18\xFAa-cV[[\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP\x80\x80`\x01\x01\x91PPa\x17\xDBV[P\x82`\x02\x85`\x02\x81\x10a\x19\\Wa\x19[a-cV[[a\x01\x02\x02\x01a\x01\0\x01\x81\x90UP\x85` \x01` \x81\x01\x90a\x19|\x91\x90a)\xEDV[`\x02\x85`\x02\x81\x10a\x19\x90Wa\x19\x8Fa-cV[[a\x01\x02\x02\x01a\x01\x01\x01_a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83`\xFF\x16\x02\x17\x90UP\x82a\x02\x08`\x01\x01\x81\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x19\xE9\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7Fx\xDA\xD2\xBC\x0BG\xC6\x88\xED\x84\xF3\xFE\xE7\x9A\xBC\x18\xE6\xC9\x82-\xB0Zy\xCA\x19\xDF\xF5E3\xC7G\ra\x02\x08_\x01_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x1A\x89\x93\x92\x91\x90a6\x8BV[`@Q\x80\x91\x03\x90\xA1PPPPPPV[a\x1A\xA1a!\xD5V[\x15a\x1A\xE1W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1A\xD8\x90a3\xA4V[`@Q\x80\x91\x03\x90\xFD[a\x1A\xE9a!{V[\x15a\x1B)W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1B \x90a4\x0CV[`@Q\x80\x91\x03\x90\xFD[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Bd\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1B\x7FWa\x1B~a-cV[[a\x01\x02\x02\x01_\x01\x82`\xFF\x16a\x01\0\x81\x10a\x1B\x9CWa\x1B\x9Ba-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\x1C\x13W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1C\n\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[3a\x02\n_\x01_a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a\x1C\x84\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\xBC'H\xCF\x02\xF7\xA1)\x15%\xE8f\xEF\xC7j\xB3\xB9m2\xD7\xAF\xCB\xB2lS\xDA\xECa{8\xB4y3a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa\x1D\n\x92\x91\x90a2\xE5V[`@Q\x80\x91\x03\x90\xA1PV[a\x1D!\x82\x82\x90Pa\"\x1FV[__a\x1D+a!\xD5V[\x15a\x1E\xA1W3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80`\x01a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1Dm\x91\x90a/8V[a\x1Dw\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1D\x92Wa\x1D\x91a-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1D\xAFWa\x1D\xAEa-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x91P\x81a\x1E\x9CW3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E)\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1EDWa\x1ECa-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1EaWa\x1E`a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x90P[a\x1FOV[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x80a\x02\x06_\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1E\xDC\x91\x90a-3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02\x81\x10a\x1E\xF7Wa\x1E\xF6a-cV[[a\x01\x02\x02\x01_\x01\x86`\xFF\x16a\x01\0\x81\x10a\x1F\x14Wa\x1F\x13a-cV[[\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x91P[\x81\x80a\x1FXWP\x80[a\x1F\x97W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x1F\x8E\x90a-\xDAV[`@Q\x80\x91\x03\x90\xFD[\x83\x83`\x01_3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01\x90\x81R` \x01_ \x91\x82a\x1F\xE3\x92\x91\x90a2\x18V[Pa\x02\x0B_\x81\x81\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x92\x91\x90a \x12\x90a+\xD7V[\x91\x90a\x01\0\n\x81T\x81o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPP\x7F\x12Q\x81\xEC!\x88-\xECQ\xA29)\x05\xDF\xF3\xA8,\xBD\x02b\xF1\x8B\\\x0C\x03T\x88g\x1B@\xAF\xB23\x85\x85a\x02\x0B_\x90T\x90a\x01\0\n\x90\x04o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`@Qa \x9C\x94\x93\x92\x91\x90a7\x11V[`@Q\x80\x91\x03\x90\xA1PPPPPV[__\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a!9W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a!0\x90a+$V[`@Q\x80\x91\x03\x90\xFD[\x80__a\x01\0\n\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x02\x17\x90UPPV[__s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x02\n_\x01_\x90T\x90a\x01\0\n\x90\x04s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14\x15\x90P\x90V[__a\x02\x08`\x01\x01T\x14\x15\x90P\x90V[__\x82`\xFF\x16`\x01\x90\x1B\x84\x16\x14\x90P\x92\x91PPV[_\x81`\xFF\x16`\x01\x90\x1B\x19\x83\x16\x90P\x92\x91PPV[_a\"\x18\x82a\"\xD0V[\x90P\x91\x90PV[_\x81\x11a\"aW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"X\x90a7\x99V[`@Q\x80\x91\x03\x90\xFD[a\x02\x07_\x01_\x90T\x90a\x01\0\n\x90\x04a\xFF\xFF\x16a\xFF\xFF\x16\x81\x11\x15a\"\xBAW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\"\xB1\x90a8\x01V[`@Q\x80\x91\x03\x90\xFD[PV[_\x81`\xFF\x16`\x01\x90\x1B\x83\x17\x90P\x92\x91PPV[_`\x07a\"\xEEo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a#\x9CV[\x90\x1B\x90P`\x06a#\ng\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x05a#$c\xFF\xFF\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x04a#<a\xFF\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x03a#S`\xFF\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P`\x02a#j`\x0F\x83\x85\x90\x1C\x11a#\x9CV[\x90\x1B\x81\x17\x90P}\x01\x01\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x1C\x1A\x81\x17\x90P\x91\x90PV[_\x81\x15\x15\x90P\x91\x90PV[`@Q\x80`\xC0\x01`@R\x80a#\xBAa$>V[\x81R` \x01a#\xC7a$ZV[\x81R` \x01a#\xD4a$>V[\x81R` \x01a#\xE1a$|V[\x81R` \x01_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90V[`@Q\x80`@\x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01``\x81RP\x90V[`@Q\x80`@\x01`@R\x80``\x81R` \x01_`\xFF\x16\x81RP\x90V[`@Q\x80`@\x01`@R\x80_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81R` \x01_\x81RP\x90V[`@Q\x80` \x01`@R\x80_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81RP\x90V[__\xFD[__\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a$\xC8\x81a$\xACV[\x81\x14a$\xD2W__\xFD[PV[_\x815\x90Pa$\xE3\x81a$\xBFV[\x92\x91PPV[_`\xFF\x82\x16\x90P\x91\x90PV[a$\xFE\x81a$\xE9V[\x81\x14a%\x08W__\xFD[PV[_\x815\x90Pa%\x19\x81a$\xF5V[\x92\x91PPV[__`@\x83\x85\x03\x12\x15a%5Wa%4a$\xA4V[[_a%B\x85\x82\x86\x01a$\xD5V[\x92PP` a%S\x85\x82\x86\x01a%\x0BV[\x91PP\x92P\x92\x90PV[__\xFD[_` \x82\x84\x03\x12\x15a%vWa%ua%]V[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a%\x94Wa%\x93a$\xA4V[[_a%\xA1\x84\x82\x85\x01a%aV[\x91PP\x92\x91PPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P` \x82\x01\x90P\x91\x90PV[_s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[_a%\xFC\x82a%\xD3V[\x90P\x91\x90PV[a&\x0C\x81a%\xF2V[\x82RPPV[_\x81Q\x90P\x91\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x83^_\x83\x83\x01RPPPV[_`\x1F\x19`\x1F\x83\x01\x16\x90P\x91\x90PV[_a&T\x82a&\x12V[a&^\x81\x85a&\x1CV[\x93Pa&n\x81\x85` \x86\x01a&,V[a&w\x81a&:V[\x84\x01\x91PP\x92\x91PPV[_`@\x83\x01_\x83\x01Qa&\x97_\x86\x01\x82a&\x03V[P` \x83\x01Q\x84\x82\x03` \x86\x01Ra&\xAF\x82\x82a&JV[\x91PP\x80\x91PP\x92\x91PPV[_a&\xC7\x83\x83a&\x82V[\x90P\x92\x91PPV[_` \x82\x01\x90P\x91\x90PV[_a&\xE5\x82a%\xAAV[a&\xEF\x81\x85a%\xB4V[\x93P\x83` \x82\x02\x85\x01a'\x01\x85a%\xC4V[\x80_[\x85\x81\x10\x15a'<W\x84\x84\x03\x89R\x81Qa'\x1D\x85\x82a&\xBCV[\x94Pa'(\x83a&\xCFV[\x92P` \x8A\x01\x99PP`\x01\x81\x01\x90Pa'\x04V[P\x82\x97P\x87\x95PPPPPP\x92\x91PPV[a'W\x81a$\xE9V[\x82RPPV[_`@\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra'w\x82\x82a&\xDBV[\x91PP` \x83\x01Qa'\x8C` \x86\x01\x82a'NV[P\x80\x91PP\x92\x91PPV[a'\xA0\x81a$\xACV[\x82RPPV[_\x81\x90P\x91\x90PV[a'\xB8\x81a'\xA6V[\x82RPPV[`@\x82\x01_\x82\x01Qa'\xD2_\x85\x01\x82a'\x97V[P` \x82\x01Qa'\xE5` \x85\x01\x82a'\xAFV[PPPPV[` \x82\x01_\x82\x01Qa'\xFF_\x85\x01\x82a&\x03V[PPPPV[_o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90P\x91\x90PV[a()\x81a(\x05V[\x82RPPV[_`\xE0\x83\x01_\x83\x01Q\x84\x82\x03_\x86\x01Ra(I\x82\x82a']V[\x91PP` \x83\x01Qa(^` \x86\x01\x82a'\xBEV[P`@\x83\x01Q\x84\x82\x03``\x86\x01Ra(v\x82\x82a']V[\x91PP``\x83\x01Qa(\x8B`\x80\x86\x01\x82a'\xEBV[P`\x80\x83\x01Qa(\x9E`\xA0\x86\x01\x82a'\x97V[P`\xA0\x83\x01Qa(\xB1`\xC0\x86\x01\x82a( V[P\x80\x91PP\x92\x91PPV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra(\xD4\x81\x84a(/V[\x90P\x92\x91PPV[__\xFD[__\xFD[__\xFD[__\x83`\x1F\x84\x01\x12a(\xFDWa(\xFCa(\xDCV[[\x825\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\x1AWa)\x19a(\xE0V[[` \x83\x01\x91P\x83`\x01\x82\x02\x83\x01\x11\x15a)6Wa)5a(\xE4V[[\x92P\x92\x90PV[__` \x83\x85\x03\x12\x15a)SWa)Ra$\xA4V[[_\x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)pWa)oa$\xA8V[[a)|\x85\x82\x86\x01a(\xE8V[\x92P\x92PP\x92P\x92\x90PV[_`@\x82\x84\x03\x12\x15a)\x9DWa)\x9Ca%]V[[\x81\x90P\x92\x91PPV[_` \x82\x84\x03\x12\x15a)\xBBWa)\xBAa$\xA4V[[_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a)\xD8Wa)\xD7a$\xA8V[[a)\xE4\x84\x82\x85\x01a)\x88V[\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a*\x02Wa*\x01a$\xA4V[[_a*\x0F\x84\x82\x85\x01a%\x0BV[\x91PP\x92\x91PPV[___`@\x84\x86\x03\x12\x15a*/Wa*.a$\xA4V[[_a*<\x86\x82\x87\x01a%\x0BV[\x93PP` \x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a*]Wa*\\a$\xA8V[[a*i\x86\x82\x87\x01a(\xE8V[\x92P\x92PP\x92P\x92P\x92V[a*~\x81a%\xF2V[\x81\x14a*\x88W__\xFD[PV[_\x815\x90Pa*\x99\x81a*uV[\x92\x91PPV[_` \x82\x84\x03\x12\x15a*\xB4Wa*\xB3a$\xA4V[[_a*\xC1\x84\x82\x85\x01a*\x8BV[\x91PP\x92\x91PPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x7Fnot the owner\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+\x0E`\r\x83a*\xCAV[\x91Pa+\x19\x82a*\xDAV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+;\x81a+\x02V[\x90P\x91\x90PV[\x7Fno maintenance\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a+v`\x0E\x83a*\xCAV[\x91Pa+\x81\x82a+BV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra+\xA3\x81a+jV[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_a+\xE1\x82a(\x05V[\x91Po\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a,\x03Wa,\x02a+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[a,\x17\x81a(\x05V[\x82RPPV[_` \x82\x01\x90Pa,0_\x83\x01\x84a,\x0EV[\x92\x91PPV[\x7Fno migration\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,j`\x0C\x83a*\xCAV[\x91Pa,u\x82a,6V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\x97\x81a,^V[\x90P\x91\x90PV[\x7Fwrong migration id\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a,\xD2`\x12\x83a*\xCAV[\x91Pa,\xDD\x82a,\x9EV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra,\xFF\x81a,\xC6V[\x90P\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[_a-=\x82a$\xACV[\x91Pa-H\x83a$\xACV[\x92P\x82a-XWa-Wa-\x06V[[\x82\x82\x06\x90P\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x7Fwrong operator\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a-\xC4`\x0E\x83a*\xCAV[\x91Pa-\xCF\x82a-\x90V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra-\xF1\x81a-\xB8V[\x90P\x91\x90PV[a.\x01\x81a$\xACV[\x82RPPV[a.\x10\x81a%\xF2V[\x82RPPV[_``\x82\x01\x90Pa.)_\x83\x01\x86a-\xF8V[a.6` \x83\x01\x85a.\x07V[a.C`@\x83\x01\x84a,\x0EV[\x94\x93PPPPV[_a\xFF\xFF\x82\x16\x90P\x91\x90PV[a.a\x81a.KV[\x81\x14a.kW__\xFD[PV[_\x815a.z\x81a.XV[\x80\x91PP\x91\x90PV[_\x81_\x1B\x90P\x91\x90PV[_a\xFF\xFFa.\x9B\x84a.\x83V[\x93P\x80\x19\x83\x16\x92P\x80\x84\x16\x83\x17\x91PP\x92\x91PPV[_\x81\x90P\x91\x90PV[_a.\xD4a.\xCFa.\xCA\x84a.KV[a.\xB1V[a.KV[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a.\xED\x82a.\xBAV[a/\0a.\xF9\x82a.\xDBV[\x83Ta.\x8EV[\x82UPPPV[_\x81\x01_\x83\x01\x80a/\x17\x81a.nV[\x90Pa/#\x81\x84a.\xE4V[PPPPPV[a/4\x82\x82a/\x07V[PPV[_a/B\x82a$\xACV[\x91Pa/M\x83a$\xACV[\x92P\x82\x82\x03\x90Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a/mWa/la+\xAAV[[\x92\x91PPV[_a/}\x82a'\xA6V[\x91Pa/\x88\x83a'\xA6V[\x92P\x82\x82\x01\x90P\x80\x82\x11\x15a/\xA0Wa/\x9Fa+\xAAV[[\x92\x91PPV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[_`\x02\x82\x04\x90P`\x01\x82\x16\x80a0\x17W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a0*Wa0)a/\xD3V[[P\x91\x90PV[_a0:\x82a'\xA6V[\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a0lWa0ka+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[_\x82\x90P\x92\x91PPV[_\x81\x90P\x81_R` _ \x90P\x91\x90PV[_` `\x1F\x83\x01\x04\x90P\x91\x90PV[_\x82\x82\x1B\x90P\x92\x91PPV[_`\x08\x83\x02a0\xDD\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82a0\xA2V[a0\xE7\x86\x83a0\xA2V[\x95P\x80\x19\x84\x16\x93P\x80\x86\x16\x84\x17\x92PPP\x93\x92PPPV[_a1\x19a1\x14a1\x0F\x84a'\xA6V[a.\xB1V[a'\xA6V[\x90P\x91\x90PV[_\x81\x90P\x91\x90PV[a12\x83a0\xFFV[a1Fa1>\x82a1 V[\x84\x84Ta0\xAEV[\x82UPPPPV[__\x90P\x90V[a1]a1NV[a1h\x81\x84\x84a1)V[PPPV[[\x81\x81\x10\x15a1\x8BWa1\x80_\x82a1UV[`\x01\x81\x01\x90Pa1nV[PPV[`\x1F\x82\x11\x15a1\xD0Wa1\xA1\x81a0\x81V[a1\xAA\x84a0\x93V[\x81\x01` \x85\x10\x15a1\xB9W\x81\x90P[a1\xCDa1\xC5\x85a0\x93V[\x83\x01\x82a1mV[PP[PPPV[_\x82\x82\x1C\x90P\x92\x91PPV[_a1\xF0_\x19\x84`\x08\x02a1\xD5V[\x19\x80\x83\x16\x91PP\x92\x91PPV[_a2\x08\x83\x83a1\xE1V[\x91P\x82`\x02\x02\x82\x17\x90P\x92\x91PPV[a2\"\x83\x83a0wV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a2;Wa2:a/\xA6V[[a2E\x82Ta0\0V[a2P\x82\x82\x85a1\x8FV[_`\x1F\x83\x11`\x01\x81\x14a2}W_\x84\x15a2kW\x82\x87\x015\x90P[a2u\x85\x82a1\xFDV[\x86UPa2\xDCV[`\x1F\x19\x84\x16a2\x8B\x86a0\x81V[_[\x82\x81\x10\x15a2\xB2W\x84\x89\x015\x82U`\x01\x82\x01\x91P` \x85\x01\x94P` \x81\x01\x90Pa2\x8DV[\x86\x83\x10\x15a2\xCFW\x84\x89\x015a2\xCB`\x1F\x89\x16\x82a1\xE1V[\x83UP[`\x01`\x02\x88\x02\x01\x88UPPP[PPPPPPPV[_`@\x82\x01\x90Pa2\xF8_\x83\x01\x85a.\x07V[a3\x05` \x83\x01\x84a,\x0EV[\x93\x92PPPV[_a3\x16\x82a$\xACV[\x91P_\x82\x03a3(Wa3'a+\xAAV[[`\x01\x82\x03\x90P\x91\x90PV[_`@\x82\x01\x90Pa3F_\x83\x01\x85a-\xF8V[a3S` \x83\x01\x84a,\x0EV[\x93\x92PPPV[\x7Fmigration in progress\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a3\x8E`\x15\x83a*\xCAV[\x91Pa3\x99\x82a3ZV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra3\xBB\x81a3\x82V[\x90P\x91\x90PV[\x7Fmaintenance in progress\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a3\xF6`\x17\x83a*\xCAV[\x91Pa4\x01\x82a3\xC2V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra4#\x81a3\xEAV[\x90P\x91\x90PV[_a44\x82a$\xACV[\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a4NWa4Ma+\xAAV[[`\x01\x82\x01\x90P\x91\x90PV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a4\x81Wa4\x80a4YV[[\x80\x84\x01\x92P\x825\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a4\xA3Wa4\xA2a4]V[[` \x83\x01\x92P`@\x82\x026\x03\x83\x13\x15a4\xBFWa4\xBEa4aV[[P\x92P\x92\x90PV[__\xFD[__\xFD[__\xFD[__\x835`\x01` \x03\x846\x03\x03\x81\x12a4\xEFWa4\xEEa4\xCFV[[\x83\x81\x01\x92P\x825\x91P` \x83\x01\x92Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a5\x17Wa5\x16a4\xC7V[[`@\x82\x026\x03\x83\x13\x15a5-Wa5,a4\xCBV[[P\x92P\x92\x90PV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[_\x81\x90P\x91\x90PV[_a5\\` \x84\x01\x84a%\x0BV[\x90P\x92\x91PPV[_a5r` \x84\x01\x84a*\x8BV[\x90P\x92\x91PPV[`@\x82\x01a5\x8A_\x83\x01\x83a5NV[a5\x96_\x85\x01\x82a'NV[Pa5\xA4` \x83\x01\x83a5dV[a5\xB1` \x85\x01\x82a&\x03V[PPPPV[_a5\xC2\x83\x83a5zV[`@\x83\x01\x90P\x92\x91PPV[_\x82\x90P\x92\x91PPV[_`@\x82\x01\x90P\x91\x90PV[_a5\xEF\x83\x85a55V[\x93Pa5\xFA\x82a5EV[\x80_[\x85\x81\x10\x15a62Wa6\x0F\x82\x84a5\xCEV[a6\x19\x88\x82a5\xB7V[\x97Pa6$\x83a5\xD8V[\x92PP`\x01\x81\x01\x90Pa5\xFDV[P\x85\x92PPP\x93\x92PPPV[_`@\x83\x01a6P_\x84\x01\x84a4\xD3V[\x85\x83\x03_\x87\x01Ra6b\x83\x82\x84a5\xE4V[\x92PPPa6s` \x84\x01\x84a5NV[a6\x80` \x86\x01\x82a'NV[P\x80\x91PP\x92\x91PPV[_``\x82\x01\x90Pa6\x9E_\x83\x01\x86a-\xF8V[\x81\x81\x03` \x83\x01Ra6\xB0\x81\x85a6?V[\x90Pa6\xBF`@\x83\x01\x84a,\x0EV[\x94\x93PPPPV[_\x82\x82R` \x82\x01\x90P\x92\x91PPV[\x82\x81\x837_\x83\x83\x01RPPPV[_a6\xF0\x83\x85a6\xC7V[\x93Pa6\xFD\x83\x85\x84a6\xD7V[a7\x06\x83a&:V[\x84\x01\x90P\x93\x92PPPV[_``\x82\x01\x90Pa7$_\x83\x01\x87a.\x07V[\x81\x81\x03` \x83\x01Ra77\x81\x85\x87a6\xE5V[\x90Pa7F`@\x83\x01\x84a,\x0EV[\x95\x94PPPPPV[\x7Fempty operator data\0\0\0\0\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\x83`\x13\x83a*\xCAV[\x91Pa7\x8E\x82a7OV[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra7\xB0\x81a7wV[\x90P\x91\x90PV[\x7Foperator data too large\0\0\0\0\0\0\0\0\0_\x82\x01RPV[_a7\xEB`\x17\x83a*\xCAV[\x91Pa7\xF6\x82a7\xB7V[` \x82\x01\x90P\x91\x90PV[_` \x82\x01\x90P\x81\x81\x03_\x83\x01Ra8\x18\x81a7\xDFV[\x90P\x91\x90PV\xFE\xA2dipfsX\"\x12 \xFA\x04\xDE\xADB^j\xA2\xEEQe+w\xCD\x8B\xEC4O\x89\xD5\xA5\xD1\x8BB\xF4\x88\x9Bz\xBA\xD1s\"dsolcC\0\x08\x1C\x003",
    );
    /**```solidity
struct ClusterView { KeyspaceView keyspace; Migration migration; KeyspaceView migrationKeyspace; Maintenance maintenance; uint64 keyspaceVersion; uint128 version; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClusterView {
        #[allow(missing_docs)]
        pub keyspace: <KeyspaceView as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub migration: <Migration as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub migrationKeyspace: <KeyspaceView as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub maintenance: <Maintenance as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub keyspaceVersion: u64,
        #[allow(missing_docs)]
        pub version: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            KeyspaceView,
            Migration,
            KeyspaceView,
            Maintenance,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<128>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <KeyspaceView as alloy::sol_types::SolType>::RustType,
            <Migration as alloy::sol_types::SolType>::RustType,
            <KeyspaceView as alloy::sol_types::SolType>::RustType,
            <Maintenance as alloy::sol_types::SolType>::RustType,
            u64,
            u128,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClusterView> for UnderlyingRustTuple<'_> {
            fn from(value: ClusterView) -> Self {
                (
                    value.keyspace,
                    value.migration,
                    value.migrationKeyspace,
                    value.maintenance,
                    value.keyspaceVersion,
                    value.version,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClusterView {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    keyspace: tuple.0,
                    migration: tuple.1,
                    migrationKeyspace: tuple.2,
                    maintenance: tuple.3,
                    keyspaceVersion: tuple.4,
                    version: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ClusterView {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ClusterView {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <KeyspaceView as alloy_sol_types::SolType>::tokenize(&self.keyspace),
                    <Migration as alloy_sol_types::SolType>::tokenize(&self.migration),
                    <KeyspaceView as alloy_sol_types::SolType>::tokenize(
                        &self.migrationKeyspace,
                    ),
                    <Maintenance as alloy_sol_types::SolType>::tokenize(
                        &self.maintenance,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.keyspaceVersion),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClusterView {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ClusterView {
            const NAME: &'static str = "ClusterView";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ClusterView(KeyspaceView keyspace,Migration migration,KeyspaceView migrationKeyspace,Maintenance maintenance,uint64 keyspaceVersion,uint128 version)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(4);
                components
                    .push(
                        <KeyspaceView as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <KeyspaceView as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(<Migration as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(
                        <Migration as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <KeyspaceView as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <KeyspaceView as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
                    .push(
                        <Maintenance as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <Maintenance as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <KeyspaceView as alloy_sol_types::SolType>::eip712_data_word(
                            &self.keyspace,
                        )
                        .0,
                    <Migration as alloy_sol_types::SolType>::eip712_data_word(
                            &self.migration,
                        )
                        .0,
                    <KeyspaceView as alloy_sol_types::SolType>::eip712_data_word(
                            &self.migrationKeyspace,
                        )
                        .0,
                    <Maintenance as alloy_sol_types::SolType>::eip712_data_word(
                            &self.maintenance,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.keyspaceVersion,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.version)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClusterView {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <KeyspaceView as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.keyspace,
                    )
                    + <Migration as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.migration,
                    )
                    + <KeyspaceView as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.migrationKeyspace,
                    )
                    + <Maintenance as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maintenance,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.keyspaceVersion,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.version,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <KeyspaceView as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.keyspace,
                    out,
                );
                <Migration as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.migration,
                    out,
                );
                <KeyspaceView as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.migrationKeyspace,
                    out,
                );
                <Maintenance as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maintenance,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.keyspaceVersion,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    128,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.version,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct KeyspaceSlot { uint8 idx; address operator; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyspaceSlot {
        #[allow(missing_docs)]
        pub idx: u8,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KeyspaceSlot> for UnderlyingRustTuple<'_> {
            fn from(value: KeyspaceSlot) -> Self {
                (value.idx, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KeyspaceSlot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    idx: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KeyspaceSlot {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KeyspaceSlot {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.idx),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KeyspaceSlot {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KeyspaceSlot {
            const NAME: &'static str = "KeyspaceSlot";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KeyspaceSlot(uint8 idx,address operator)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.idx)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KeyspaceSlot {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.idx)
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.idx, out);
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct KeyspaceView { NodeOperator[] operators; uint8 replicationStrategy; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct KeyspaceView {
        #[allow(missing_docs)]
        pub operators: alloy::sol_types::private::Vec<
            <NodeOperator as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub replicationStrategy: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<NodeOperator>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<
                <NodeOperator as alloy::sol_types::SolType>::RustType,
            >,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<KeyspaceView> for UnderlyingRustTuple<'_> {
            fn from(value: KeyspaceView) -> Self {
                (value.operators, value.replicationStrategy)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for KeyspaceView {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operators: tuple.0,
                    replicationStrategy: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for KeyspaceView {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for KeyspaceView {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        NodeOperator,
                    > as alloy_sol_types::SolType>::tokenize(&self.operators),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.replicationStrategy),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for KeyspaceView {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for KeyspaceView {
            const NAME: &'static str = "KeyspaceView";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "KeyspaceView(NodeOperator[] operators,uint8 replicationStrategy)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <NodeOperator as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <NodeOperator as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Array<
                        NodeOperator,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operators)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.replicationStrategy,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for KeyspaceView {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Array<
                        NodeOperator,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operators,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.replicationStrategy,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Array<
                    NodeOperator,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operators,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.replicationStrategy,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Maintenance { address slot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Maintenance {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Maintenance> for UnderlyingRustTuple<'_> {
            fn from(value: Maintenance) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Maintenance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Maintenance {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Maintenance {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.slot,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Maintenance {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Maintenance {
            const NAME: &'static str = "Maintenance";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("Maintenance(address slot)")
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                        &self.slot,
                    )
                    .0
                    .to_vec()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Maintenance {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.slot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.slot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Migration { uint64 id; uint256 pullingOperatorsBitmask; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Migration {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub pullingOperatorsBitmask: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Migration> for UnderlyingRustTuple<'_> {
            fn from(value: Migration) -> Self {
                (value.id, value.pullingOperatorsBitmask)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Migration {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    pullingOperatorsBitmask: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Migration {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Migration {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.pullingOperatorsBitmask,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Migration {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Migration {
            const NAME: &'static str = "Migration";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Migration(uint64 id,uint256 pullingOperatorsBitmask)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.pullingOperatorsBitmask,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Migration {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pullingOperatorsBitmask,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pullingOperatorsBitmask,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct MigrationPlan { KeyspaceSlot[] slots; uint8 replicationStrategy; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MigrationPlan {
        #[allow(missing_docs)]
        pub slots: alloy::sol_types::private::Vec<
            <KeyspaceSlot as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub replicationStrategy: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<KeyspaceSlot>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<
                <KeyspaceSlot as alloy::sol_types::SolType>::RustType,
            >,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MigrationPlan> for UnderlyingRustTuple<'_> {
            fn from(value: MigrationPlan) -> Self {
                (value.slots, value.replicationStrategy)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MigrationPlan {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    slots: tuple.0,
                    replicationStrategy: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for MigrationPlan {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for MigrationPlan {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        KeyspaceSlot,
                    > as alloy_sol_types::SolType>::tokenize(&self.slots),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.replicationStrategy),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MigrationPlan {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for MigrationPlan {
            const NAME: &'static str = "MigrationPlan";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "MigrationPlan(KeyspaceSlot[] slots,uint8 replicationStrategy)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <KeyspaceSlot as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <KeyspaceSlot as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Array<
                        KeyspaceSlot,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.slots)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.replicationStrategy,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MigrationPlan {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Array<
                        KeyspaceSlot,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.slots)
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.replicationStrategy,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Array<
                    KeyspaceSlot,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.slots,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.replicationStrategy,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct NodeOperator { address addr; bytes data; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NodeOperator {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NodeOperator> for UnderlyingRustTuple<'_> {
            fn from(value: NodeOperator) -> Self {
                (value.addr, value.data)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NodeOperator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    data: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for NodeOperator {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for NodeOperator {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for NodeOperator {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for NodeOperator {
            const NAME: &'static str = "NodeOperator";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "NodeOperator(address addr,bytes data)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for NodeOperator {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Settings { uint16 maxOperatorDataBytes; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Settings {
        #[allow(missing_docs)]
        pub maxOperatorDataBytes: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u16,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Settings> for UnderlyingRustTuple<'_> {
            fn from(value: Settings) -> Self {
                (value.maxOperatorDataBytes,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Settings {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    maxOperatorDataBytes: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Settings {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Settings {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxOperatorDataBytes),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Settings {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Settings {
            const NAME: &'static str = "Settings";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Settings(uint16 maxOperatorDataBytes)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::SolType>::eip712_data_word(
                        &self.maxOperatorDataBytes,
                    )
                    .0
                    .to_vec()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Settings {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxOperatorDataBytes,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxOperatorDataBytes,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Event with signature `MaintenanceAborted(uint128)` and selector `0x8fb9cd054d0a022110cced239e908b834e4cd219511856d4eaae3051d932d604`.
```solidity
event MaintenanceAborted(uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MaintenanceAborted {
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MaintenanceAborted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<128>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MaintenanceAborted(uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                143u8,
                185u8,
                205u8,
                5u8,
                77u8,
                10u8,
                2u8,
                33u8,
                16u8,
                204u8,
                237u8,
                35u8,
                158u8,
                144u8,
                139u8,
                131u8,
                78u8,
                76u8,
                210u8,
                25u8,
                81u8,
                24u8,
                86u8,
                212u8,
                234u8,
                174u8,
                48u8,
                81u8,
                217u8,
                50u8,
                214u8,
                4u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { clusterVersion: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MaintenanceAborted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MaintenanceAborted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MaintenanceAborted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MaintenanceCompleted(address,uint128)` and selector `0xf91067eb420c28d3124865fc996e6aa9d541b9b4fef9188cb965a6cc6491638e`.
```solidity
event MaintenanceCompleted(address operatorAddress, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MaintenanceCompleted {
        #[allow(missing_docs)]
        pub operatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MaintenanceCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MaintenanceCompleted(address,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                249u8,
                16u8,
                103u8,
                235u8,
                66u8,
                12u8,
                40u8,
                211u8,
                18u8,
                72u8,
                101u8,
                252u8,
                153u8,
                110u8,
                106u8,
                169u8,
                213u8,
                65u8,
                185u8,
                180u8,
                254u8,
                249u8,
                24u8,
                140u8,
                185u8,
                101u8,
                166u8,
                204u8,
                100u8,
                145u8,
                99u8,
                142u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operatorAddress: data.0,
                    clusterVersion: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MaintenanceCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MaintenanceCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MaintenanceCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MaintenanceStarted(address,uint128)` and selector `0xbc2748cf02f7a1291525e866efc76ab3b96d32d7afcbb26c53daec617b38b479`.
```solidity
event MaintenanceStarted(address operatorAddress, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MaintenanceStarted {
        #[allow(missing_docs)]
        pub operatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MaintenanceStarted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MaintenanceStarted(address,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8,
                39u8,
                72u8,
                207u8,
                2u8,
                247u8,
                161u8,
                41u8,
                21u8,
                37u8,
                232u8,
                102u8,
                239u8,
                199u8,
                106u8,
                179u8,
                185u8,
                109u8,
                50u8,
                215u8,
                175u8,
                203u8,
                178u8,
                108u8,
                83u8,
                218u8,
                236u8,
                97u8,
                123u8,
                56u8,
                180u8,
                121u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operatorAddress: data.0,
                    clusterVersion: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MaintenanceStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MaintenanceStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MaintenanceStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MigrationAborted(uint64,uint128)` and selector `0xf73240422246f63ed633ef3ce0726b8ab8fb69d46c8a4e5ecb0b2922668674a1`.
```solidity
event MigrationAborted(uint64 id, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MigrationAborted {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MigrationAborted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MigrationAborted(uint64,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                247u8,
                50u8,
                64u8,
                66u8,
                34u8,
                70u8,
                246u8,
                62u8,
                214u8,
                51u8,
                239u8,
                60u8,
                224u8,
                114u8,
                107u8,
                138u8,
                184u8,
                251u8,
                105u8,
                212u8,
                108u8,
                138u8,
                78u8,
                94u8,
                203u8,
                11u8,
                41u8,
                34u8,
                102u8,
                134u8,
                116u8,
                161u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: data.0,
                    clusterVersion: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MigrationAborted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MigrationAborted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MigrationAborted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MigrationCompleted(uint64,address,uint128)` and selector `0x01269879535f40ee8957e15e160bf1866c5e2728ff0cbc583d848821e2639b4e`.
```solidity
event MigrationCompleted(uint64 id, address operatorAddress, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MigrationCompleted {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub operatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MigrationCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MigrationCompleted(uint64,address,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                1u8,
                38u8,
                152u8,
                121u8,
                83u8,
                95u8,
                64u8,
                238u8,
                137u8,
                87u8,
                225u8,
                94u8,
                22u8,
                11u8,
                241u8,
                134u8,
                108u8,
                94u8,
                39u8,
                40u8,
                255u8,
                12u8,
                188u8,
                88u8,
                61u8,
                132u8,
                136u8,
                33u8,
                226u8,
                99u8,
                155u8,
                78u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: data.0,
                    operatorAddress: data.1,
                    clusterVersion: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MigrationCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MigrationCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MigrationCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MigrationDataPullCompleted(uint64,address,uint128)` and selector `0xaf5e90e72015f43138f66b4cd08bd1dfa2839030104f22a00af843fe847c6d19`.
```solidity
event MigrationDataPullCompleted(uint64 id, address operatorAddress, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MigrationDataPullCompleted {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub operatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MigrationDataPullCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MigrationDataPullCompleted(uint64,address,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                175u8,
                94u8,
                144u8,
                231u8,
                32u8,
                21u8,
                244u8,
                49u8,
                56u8,
                246u8,
                107u8,
                76u8,
                208u8,
                139u8,
                209u8,
                223u8,
                162u8,
                131u8,
                144u8,
                48u8,
                16u8,
                79u8,
                34u8,
                160u8,
                10u8,
                248u8,
                67u8,
                254u8,
                132u8,
                124u8,
                109u8,
                25u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: data.0,
                    operatorAddress: data.1,
                    clusterVersion: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MigrationDataPullCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MigrationDataPullCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &MigrationDataPullCompleted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `MigrationStarted(uint64,((uint8,address)[],uint8),uint128)` and selector `0x78dad2bc0b47c688ed84f3fee79abc18e6c9822db05a79ca19dff54533c7470d`.
```solidity
event MigrationStarted(uint64 id, MigrationPlan plan, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct MigrationStarted {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub plan: <MigrationPlan as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MigrationStarted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                MigrationPlan,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MigrationStarted(uint64,((uint8,address)[],uint8),uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8,
                218u8,
                210u8,
                188u8,
                11u8,
                71u8,
                198u8,
                136u8,
                237u8,
                132u8,
                243u8,
                254u8,
                231u8,
                154u8,
                188u8,
                24u8,
                230u8,
                201u8,
                130u8,
                45u8,
                176u8,
                90u8,
                121u8,
                202u8,
                25u8,
                223u8,
                245u8,
                69u8,
                51u8,
                199u8,
                71u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: data.0,
                    plan: data.1,
                    clusterVersion: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <MigrationPlan as alloy_sol_types::SolType>::tokenize(&self.plan),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MigrationStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MigrationStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MigrationStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `NodeOperatorDataUpdated(address,bytes,uint128)` and selector `0x125181ec21882dec51a2392905dff3a82cbd0262f18b5c0c035488671b40afb2`.
```solidity
event NodeOperatorDataUpdated(address operatorAddress, bytes data, uint128 clusterVersion);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NodeOperatorDataUpdated {
        #[allow(missing_docs)]
        pub operatorAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub clusterVersion: u128,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NodeOperatorDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<128>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NodeOperatorDataUpdated(address,bytes,uint128)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                18u8,
                81u8,
                129u8,
                236u8,
                33u8,
                136u8,
                45u8,
                236u8,
                81u8,
                162u8,
                57u8,
                41u8,
                5u8,
                223u8,
                243u8,
                168u8,
                44u8,
                189u8,
                2u8,
                98u8,
                241u8,
                139u8,
                92u8,
                12u8,
                3u8,
                84u8,
                136u8,
                103u8,
                27u8,
                64u8,
                175u8,
                178u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operatorAddress: data.0,
                    data: data.1,
                    clusterVersion: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operatorAddress,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        128,
                    > as alloy_sol_types::SolType>::tokenize(&self.clusterVersion),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NodeOperatorDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NodeOperatorDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &NodeOperatorDataUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(Settings initialSettings, address[] initialOperators);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub initialSettings: <Settings as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub initialOperators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Settings,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Settings as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.initialSettings, value.initialOperators)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        initialSettings: tuple.0,
                        initialOperators: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                Settings,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Settings as alloy_sol_types::SolType>::tokenize(
                        &self.initialSettings,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialOperators),
                )
            }
        }
    };
    /**Function with signature `abortMaintenance()` and selector `0x3048bfba`.
```solidity
function abortMaintenance() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abortMaintenanceCall {}
    ///Container type for the return parameters of the [`abortMaintenance()`](abortMaintenanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abortMaintenanceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abortMaintenanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: abortMaintenanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for abortMaintenanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abortMaintenanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: abortMaintenanceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for abortMaintenanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for abortMaintenanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = abortMaintenanceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "abortMaintenance()";
            const SELECTOR: [u8; 4] = [48u8, 72u8, 191u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `abortMigration()` and selector `0xc130809a`.
```solidity
function abortMigration() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abortMigrationCall {}
    ///Container type for the return parameters of the [`abortMigration()`](abortMigrationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct abortMigrationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abortMigrationCall> for UnderlyingRustTuple<'_> {
                fn from(value: abortMigrationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for abortMigrationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<abortMigrationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: abortMigrationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for abortMigrationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for abortMigrationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = abortMigrationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "abortMigration()";
            const SELECTOR: [u8; 4] = [193u8, 48u8, 128u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `completeMaintenance()` and selector `0xad36e6d0`.
```solidity
function completeMaintenance() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeMaintenanceCall {}
    ///Container type for the return parameters of the [`completeMaintenance()`](completeMaintenanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeMaintenanceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeMaintenanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeMaintenanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeMaintenanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeMaintenanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeMaintenanceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeMaintenanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for completeMaintenanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = completeMaintenanceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "completeMaintenance()";
            const SELECTOR: [u8; 4] = [173u8, 54u8, 230u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `completeMigration(uint64,uint8)` and selector `0x55a47d0a`.
```solidity
function completeMigration(uint64 id, uint8 operatorIdx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeMigrationCall {
        #[allow(missing_docs)]
        pub id: u64,
        #[allow(missing_docs)]
        pub operatorIdx: u8,
    }
    ///Container type for the return parameters of the [`completeMigration(uint64,uint8)`](completeMigrationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeMigrationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u8);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeMigrationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeMigrationCall) -> Self {
                    (value.id, value.operatorIdx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeMigrationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        id: tuple.0,
                        operatorIdx: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeMigrationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeMigrationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeMigrationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for completeMigrationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = completeMigrationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "completeMigration(uint64,uint8)";
            const SELECTOR: [u8; 4] = [85u8, 164u8, 125u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorIdx),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getView()` and selector `0x75418b9d`.
```solidity
function getView() external view returns (ClusterView memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getViewCall {}
    ///Container type for the return parameters of the [`getView()`](getViewCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getViewReturn {
        #[allow(missing_docs)]
        pub _0: <ClusterView as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getViewCall> for UnderlyingRustTuple<'_> {
                fn from(value: getViewCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getViewCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ClusterView,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ClusterView as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getViewReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getViewReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getViewReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getViewCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getViewReturn;
            type ReturnTuple<'a> = (ClusterView,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getView()";
            const SELECTOR: [u8; 4] = [117u8, 65u8, 139u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `registerNodeOperator(bytes)` and selector `0x8b5252d6`.
```solidity
function registerNodeOperator(bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerNodeOperatorCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`registerNodeOperator(bytes)`](registerNodeOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerNodeOperatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerNodeOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerNodeOperatorCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerNodeOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerNodeOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerNodeOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerNodeOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerNodeOperatorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerNodeOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerNodeOperator(bytes)";
            const SELECTOR: [u8; 4] = [139u8, 82u8, 82u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startMaintenance(uint8)` and selector `0xdd3fd269`.
```solidity
function startMaintenance(uint8 operatorIdx) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMaintenanceCall {
        #[allow(missing_docs)]
        pub operatorIdx: u8,
    }
    ///Container type for the return parameters of the [`startMaintenance(uint8)`](startMaintenanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMaintenanceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMaintenanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: startMaintenanceCall) -> Self {
                    (value.operatorIdx,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startMaintenanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operatorIdx: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMaintenanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startMaintenanceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startMaintenanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startMaintenanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startMaintenanceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startMaintenance(uint8)";
            const SELECTOR: [u8; 4] = [221u8, 63u8, 210u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorIdx),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startMigration(((uint8,address)[],uint8))` and selector `0xcdbfc62d`.
```solidity
function startMigration(MigrationPlan memory plan) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMigrationCall {
        #[allow(missing_docs)]
        pub plan: <MigrationPlan as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`startMigration(((uint8,address)[],uint8))`](startMigrationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMigrationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MigrationPlan,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MigrationPlan as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMigrationCall> for UnderlyingRustTuple<'_> {
                fn from(value: startMigrationCall) -> Self {
                    (value.plan,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startMigrationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { plan: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMigrationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startMigrationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startMigrationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startMigrationCall {
            type Parameters<'a> = (MigrationPlan,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startMigrationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startMigration(((uint8,address)[],uint8))";
            const SELECTOR: [u8; 4] = [205u8, 191u8, 198u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<MigrationPlan as alloy_sol_types::SolType>::tokenize(&self.plan),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateNodeOperatorData(uint8,bytes)` and selector `0xf019b154`.
```solidity
function updateNodeOperatorData(uint8 operatorIdx, bytes memory data) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNodeOperatorDataCall {
        #[allow(missing_docs)]
        pub operatorIdx: u8,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`updateNodeOperatorData(uint8,bytes)`](updateNodeOperatorDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNodeOperatorDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNodeOperatorDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNodeOperatorDataCall) -> Self {
                    (value.operatorIdx, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNodeOperatorDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorIdx: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNodeOperatorDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNodeOperatorDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNodeOperatorDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateNodeOperatorDataCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateNodeOperatorDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateNodeOperatorData(uint8,bytes)";
            const SELECTOR: [u8; 4] = [240u8, 25u8, 177u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorIdx),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateSettings((uint16))` and selector `0x65706f9c`.
```solidity
function updateSettings(Settings memory newSettings) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateSettingsCall {
        #[allow(missing_docs)]
        pub newSettings: <Settings as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`updateSettings((uint16))`](updateSettingsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateSettingsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Settings,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Settings as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSettingsCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateSettingsCall) -> Self {
                    (value.newSettings,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateSettingsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newSettings: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSettingsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateSettingsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateSettingsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateSettingsCall {
            type Parameters<'a> = (Settings,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateSettingsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateSettings((uint16))";
            const SELECTOR: [u8; 4] = [101u8, 112u8, 111u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Settings as alloy_sol_types::SolType>::tokenize(&self.newSettings),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`Cluster`](self) function calls.
    pub enum ClusterCalls {
        #[allow(missing_docs)]
        abortMaintenance(abortMaintenanceCall),
        #[allow(missing_docs)]
        abortMigration(abortMigrationCall),
        #[allow(missing_docs)]
        completeMaintenance(completeMaintenanceCall),
        #[allow(missing_docs)]
        completeMigration(completeMigrationCall),
        #[allow(missing_docs)]
        getView(getViewCall),
        #[allow(missing_docs)]
        registerNodeOperator(registerNodeOperatorCall),
        #[allow(missing_docs)]
        startMaintenance(startMaintenanceCall),
        #[allow(missing_docs)]
        startMigration(startMigrationCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        updateNodeOperatorData(updateNodeOperatorDataCall),
        #[allow(missing_docs)]
        updateSettings(updateSettingsCall),
    }
    #[automatically_derived]
    impl ClusterCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [48u8, 72u8, 191u8, 186u8],
            [85u8, 164u8, 125u8, 10u8],
            [101u8, 112u8, 111u8, 156u8],
            [117u8, 65u8, 139u8, 157u8],
            [139u8, 82u8, 82u8, 214u8],
            [173u8, 54u8, 230u8, 208u8],
            [193u8, 48u8, 128u8, 154u8],
            [205u8, 191u8, 198u8, 45u8],
            [221u8, 63u8, 210u8, 105u8],
            [240u8, 25u8, 177u8, 84u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ClusterCalls {
        const NAME: &'static str = "ClusterCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 11usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::abortMaintenance(_) => {
                    <abortMaintenanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::abortMigration(_) => {
                    <abortMigrationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::completeMaintenance(_) => {
                    <completeMaintenanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::completeMigration(_) => {
                    <completeMigrationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getView(_) => <getViewCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::registerNodeOperator(_) => {
                    <registerNodeOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startMaintenance(_) => {
                    <startMaintenanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startMigration(_) => {
                    <startMigrationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateNodeOperatorData(_) => {
                    <updateNodeOperatorDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateSettings(_) => {
                    <updateSettingsCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ClusterCalls>] = &[
                {
                    fn abortMaintenance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <abortMaintenanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::abortMaintenance)
                    }
                    abortMaintenance
                },
                {
                    fn completeMigration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <completeMigrationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::completeMigration)
                    }
                    completeMigration
                },
                {
                    fn updateSettings(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <updateSettingsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::updateSettings)
                    }
                    updateSettings
                },
                {
                    fn getView(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <getViewCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::getView)
                    }
                    getView
                },
                {
                    fn registerNodeOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <registerNodeOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::registerNodeOperator)
                    }
                    registerNodeOperator
                },
                {
                    fn completeMaintenance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <completeMaintenanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::completeMaintenance)
                    }
                    completeMaintenance
                },
                {
                    fn abortMigration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <abortMigrationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::abortMigration)
                    }
                    abortMigration
                },
                {
                    fn startMigration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <startMigrationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::startMigration)
                    }
                    startMigration
                },
                {
                    fn startMaintenance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <startMaintenanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::startMaintenance)
                    }
                    startMaintenance
                },
                {
                    fn updateNodeOperatorData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <updateNodeOperatorDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::updateNodeOperatorData)
                    }
                    updateNodeOperatorData
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClusterCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClusterCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::abortMaintenance(inner) => {
                    <abortMaintenanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::abortMigration(inner) => {
                    <abortMigrationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::completeMaintenance(inner) => {
                    <completeMaintenanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::completeMigration(inner) => {
                    <completeMigrationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getView(inner) => {
                    <getViewCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::registerNodeOperator(inner) => {
                    <registerNodeOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startMaintenance(inner) => {
                    <startMaintenanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startMigration(inner) => {
                    <startMigrationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateNodeOperatorData(inner) => {
                    <updateNodeOperatorDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateSettings(inner) => {
                    <updateSettingsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::abortMaintenance(inner) => {
                    <abortMaintenanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::abortMigration(inner) => {
                    <abortMigrationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::completeMaintenance(inner) => {
                    <completeMaintenanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::completeMigration(inner) => {
                    <completeMigrationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getView(inner) => {
                    <getViewCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::registerNodeOperator(inner) => {
                    <registerNodeOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startMaintenance(inner) => {
                    <startMaintenanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startMigration(inner) => {
                    <startMigrationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateNodeOperatorData(inner) => {
                    <updateNodeOperatorDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateSettings(inner) => {
                    <updateSettingsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`Cluster`](self) events.
    pub enum ClusterEvents {
        #[allow(missing_docs)]
        MaintenanceAborted(MaintenanceAborted),
        #[allow(missing_docs)]
        MaintenanceCompleted(MaintenanceCompleted),
        #[allow(missing_docs)]
        MaintenanceStarted(MaintenanceStarted),
        #[allow(missing_docs)]
        MigrationAborted(MigrationAborted),
        #[allow(missing_docs)]
        MigrationCompleted(MigrationCompleted),
        #[allow(missing_docs)]
        MigrationDataPullCompleted(MigrationDataPullCompleted),
        #[allow(missing_docs)]
        MigrationStarted(MigrationStarted),
        #[allow(missing_docs)]
        NodeOperatorDataUpdated(NodeOperatorDataUpdated),
    }
    #[automatically_derived]
    impl ClusterEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                1u8,
                38u8,
                152u8,
                121u8,
                83u8,
                95u8,
                64u8,
                238u8,
                137u8,
                87u8,
                225u8,
                94u8,
                22u8,
                11u8,
                241u8,
                134u8,
                108u8,
                94u8,
                39u8,
                40u8,
                255u8,
                12u8,
                188u8,
                88u8,
                61u8,
                132u8,
                136u8,
                33u8,
                226u8,
                99u8,
                155u8,
                78u8,
            ],
            [
                18u8,
                81u8,
                129u8,
                236u8,
                33u8,
                136u8,
                45u8,
                236u8,
                81u8,
                162u8,
                57u8,
                41u8,
                5u8,
                223u8,
                243u8,
                168u8,
                44u8,
                189u8,
                2u8,
                98u8,
                241u8,
                139u8,
                92u8,
                12u8,
                3u8,
                84u8,
                136u8,
                103u8,
                27u8,
                64u8,
                175u8,
                178u8,
            ],
            [
                120u8,
                218u8,
                210u8,
                188u8,
                11u8,
                71u8,
                198u8,
                136u8,
                237u8,
                132u8,
                243u8,
                254u8,
                231u8,
                154u8,
                188u8,
                24u8,
                230u8,
                201u8,
                130u8,
                45u8,
                176u8,
                90u8,
                121u8,
                202u8,
                25u8,
                223u8,
                245u8,
                69u8,
                51u8,
                199u8,
                71u8,
                13u8,
            ],
            [
                143u8,
                185u8,
                205u8,
                5u8,
                77u8,
                10u8,
                2u8,
                33u8,
                16u8,
                204u8,
                237u8,
                35u8,
                158u8,
                144u8,
                139u8,
                131u8,
                78u8,
                76u8,
                210u8,
                25u8,
                81u8,
                24u8,
                86u8,
                212u8,
                234u8,
                174u8,
                48u8,
                81u8,
                217u8,
                50u8,
                214u8,
                4u8,
            ],
            [
                175u8,
                94u8,
                144u8,
                231u8,
                32u8,
                21u8,
                244u8,
                49u8,
                56u8,
                246u8,
                107u8,
                76u8,
                208u8,
                139u8,
                209u8,
                223u8,
                162u8,
                131u8,
                144u8,
                48u8,
                16u8,
                79u8,
                34u8,
                160u8,
                10u8,
                248u8,
                67u8,
                254u8,
                132u8,
                124u8,
                109u8,
                25u8,
            ],
            [
                188u8,
                39u8,
                72u8,
                207u8,
                2u8,
                247u8,
                161u8,
                41u8,
                21u8,
                37u8,
                232u8,
                102u8,
                239u8,
                199u8,
                106u8,
                179u8,
                185u8,
                109u8,
                50u8,
                215u8,
                175u8,
                203u8,
                178u8,
                108u8,
                83u8,
                218u8,
                236u8,
                97u8,
                123u8,
                56u8,
                180u8,
                121u8,
            ],
            [
                247u8,
                50u8,
                64u8,
                66u8,
                34u8,
                70u8,
                246u8,
                62u8,
                214u8,
                51u8,
                239u8,
                60u8,
                224u8,
                114u8,
                107u8,
                138u8,
                184u8,
                251u8,
                105u8,
                212u8,
                108u8,
                138u8,
                78u8,
                94u8,
                203u8,
                11u8,
                41u8,
                34u8,
                102u8,
                134u8,
                116u8,
                161u8,
            ],
            [
                249u8,
                16u8,
                103u8,
                235u8,
                66u8,
                12u8,
                40u8,
                211u8,
                18u8,
                72u8,
                101u8,
                252u8,
                153u8,
                110u8,
                106u8,
                169u8,
                213u8,
                65u8,
                185u8,
                180u8,
                254u8,
                249u8,
                24u8,
                140u8,
                185u8,
                101u8,
                166u8,
                204u8,
                100u8,
                145u8,
                99u8,
                142u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ClusterEvents {
        const NAME: &'static str = "ClusterEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <MaintenanceAborted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MaintenanceAborted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MaintenanceAborted)
                }
                Some(
                    <MaintenanceCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MaintenanceCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MaintenanceCompleted)
                }
                Some(
                    <MaintenanceStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MaintenanceStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MaintenanceStarted)
                }
                Some(<MigrationAborted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MigrationAborted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MigrationAborted)
                }
                Some(
                    <MigrationCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MigrationCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MigrationCompleted)
                }
                Some(
                    <MigrationDataPullCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <MigrationDataPullCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MigrationDataPullCompleted)
                }
                Some(<MigrationStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MigrationStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::MigrationStarted)
                }
                Some(
                    <NodeOperatorDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NodeOperatorDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::NodeOperatorDataUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ClusterEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::MaintenanceAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MaintenanceCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MaintenanceStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MigrationAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MigrationCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MigrationDataPullCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MigrationStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NodeOperatorDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::MaintenanceAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MaintenanceCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MaintenanceStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MigrationAborted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MigrationCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MigrationDataPullCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MigrationStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NodeOperatorDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Cluster`](self) contract instance.

See the [wrapper's documentation](`ClusterInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ClusterInstance<T, P, N> {
        ClusterInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        initialSettings: <Settings as alloy::sol_types::SolType>::RustType,
        initialOperators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ClusterInstance<T, P, N>>,
    > {
        ClusterInstance::<T, P, N>::deploy(provider, initialSettings, initialOperators)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        initialSettings: <Settings as alloy::sol_types::SolType>::RustType,
        initialOperators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        ClusterInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, initialSettings, initialOperators)
    }
    /**A [`Cluster`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Cluster`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ClusterInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ClusterInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ClusterInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClusterInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Cluster`](self) contract instance.

See the [wrapper's documentation](`ClusterInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            initialSettings: <Settings as alloy::sol_types::SolType>::RustType,
            initialOperators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::Result<ClusterInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                initialSettings,
                initialOperators,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            initialSettings: <Settings as alloy::sol_types::SolType>::RustType,
            initialOperators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            initialSettings,
                            initialOperators,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ClusterInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ClusterInstance<T, P, N> {
            ClusterInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClusterInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`abortMaintenance`] function.
        pub fn abortMaintenance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, abortMaintenanceCall, N> {
            self.call_builder(&abortMaintenanceCall {})
        }
        ///Creates a new call builder for the [`abortMigration`] function.
        pub fn abortMigration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, abortMigrationCall, N> {
            self.call_builder(&abortMigrationCall {})
        }
        ///Creates a new call builder for the [`completeMaintenance`] function.
        pub fn completeMaintenance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, completeMaintenanceCall, N> {
            self.call_builder(&completeMaintenanceCall {})
        }
        ///Creates a new call builder for the [`completeMigration`] function.
        pub fn completeMigration(
            &self,
            id: u64,
            operatorIdx: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, completeMigrationCall, N> {
            self.call_builder(
                &completeMigrationCall {
                    id,
                    operatorIdx,
                },
            )
        }
        ///Creates a new call builder for the [`getView`] function.
        pub fn getView(&self) -> alloy_contract::SolCallBuilder<T, &P, getViewCall, N> {
            self.call_builder(&getViewCall {})
        }
        ///Creates a new call builder for the [`registerNodeOperator`] function.
        pub fn registerNodeOperator(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerNodeOperatorCall, N> {
            self.call_builder(&registerNodeOperatorCall { data })
        }
        ///Creates a new call builder for the [`startMaintenance`] function.
        pub fn startMaintenance(
            &self,
            operatorIdx: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, startMaintenanceCall, N> {
            self.call_builder(
                &startMaintenanceCall {
                    operatorIdx,
                },
            )
        }
        ///Creates a new call builder for the [`startMigration`] function.
        pub fn startMigration(
            &self,
            plan: <MigrationPlan as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, startMigrationCall, N> {
            self.call_builder(&startMigrationCall { plan })
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`updateNodeOperatorData`] function.
        pub fn updateNodeOperatorData(
            &self,
            operatorIdx: u8,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateNodeOperatorDataCall, N> {
            self.call_builder(
                &updateNodeOperatorDataCall {
                    operatorIdx,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`updateSettings`] function.
        pub fn updateSettings(
            &self,
            newSettings: <Settings as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateSettingsCall, N> {
            self.call_builder(&updateSettingsCall { newSettings })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClusterInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`MaintenanceAborted`] event.
        pub fn MaintenanceAborted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MaintenanceAborted, N> {
            self.event_filter::<MaintenanceAborted>()
        }
        ///Creates a new event filter for the [`MaintenanceCompleted`] event.
        pub fn MaintenanceCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MaintenanceCompleted, N> {
            self.event_filter::<MaintenanceCompleted>()
        }
        ///Creates a new event filter for the [`MaintenanceStarted`] event.
        pub fn MaintenanceStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MaintenanceStarted, N> {
            self.event_filter::<MaintenanceStarted>()
        }
        ///Creates a new event filter for the [`MigrationAborted`] event.
        pub fn MigrationAborted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MigrationAborted, N> {
            self.event_filter::<MigrationAborted>()
        }
        ///Creates a new event filter for the [`MigrationCompleted`] event.
        pub fn MigrationCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MigrationCompleted, N> {
            self.event_filter::<MigrationCompleted>()
        }
        ///Creates a new event filter for the [`MigrationDataPullCompleted`] event.
        pub fn MigrationDataPullCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MigrationDataPullCompleted, N> {
            self.event_filter::<MigrationDataPullCompleted>()
        }
        ///Creates a new event filter for the [`MigrationStarted`] event.
        pub fn MigrationStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MigrationStarted, N> {
            self.event_filter::<MigrationStarted>()
        }
        ///Creates a new event filter for the [`NodeOperatorDataUpdated`] event.
        pub fn NodeOperatorDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, NodeOperatorDataUpdated, N> {
            self.event_filter::<NodeOperatorDataUpdated>()
        }
    }
}
